# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/ingest/v1/ingest.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "IngestArbitraryProtobufDataStreamRequest",
    "IngestArbitraryProtobufDataStreamResponse",
    "IngestWithConfigDataChannelValue",
    "IngestWithConfigDataStreamRequest",
    "IngestWithConfigDataStreamResponse",
    "IngestServiceStub",
    "IngestServiceBase",
)

import builtins
import datetime
from collections.abc import AsyncIterable, AsyncIterator, Iterable
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
from betterproto2.grpc.grpclib_server import ServiceBase

from ....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

betterproto2.check_compiler_version("0.4.0")


@dataclass(eq=False, repr=False)
class IngestArbitraryProtobufDataStreamRequest(betterproto2.Message):
    message_type_identifier: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    message_type_display_name: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )

    asset_name: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    timestamp: "datetime.datetime | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    value: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)

    run_id: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)

    namespace: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)

    organization_id: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)

    end_stream_on_validation_error: "bool" = betterproto2.field(
        9, betterproto2.TYPE_BOOL
    )
    """
    By default, if this request fails to parse for any reason, the request is 
    stored in an error queue and the stream continues to accept data. This 
    ensures all data is saved, but only valid data is fully ingested. If this 
    is set to `true`, any validation errors end the stream and return the error to the client.
    """


default_message_pool.register_message(
    "sift.ingest.v1",
    "IngestArbitraryProtobufDataStreamRequest",
    IngestArbitraryProtobufDataStreamRequest,
)


@dataclass(eq=False, repr=False)
class IngestArbitraryProtobufDataStreamResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "sift.ingest.v1",
    "IngestArbitraryProtobufDataStreamResponse",
    IngestArbitraryProtobufDataStreamResponse,
)


@dataclass(eq=False, repr=False)
class IngestWithConfigDataChannelValue(betterproto2.Message):
    """


    Oneofs:
        - type:
    """

    string: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="type"
    )

    double: "float | None" = betterproto2.field(
        2, betterproto2.TYPE_DOUBLE, optional=True, group="type"
    )

    float: "builtins.float | None" = betterproto2.field(
        3, betterproto2.TYPE_FLOAT, optional=True, group="type"
    )

    bool: "builtins.bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True, group="type"
    )

    int32: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_INT32, optional=True, group="type"
    )

    uint32: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT32, optional=True, group="type"
    )

    int64: "int | None" = betterproto2.field(
        7, betterproto2.TYPE_INT64, optional=True, group="type"
    )

    uint64: "int | None" = betterproto2.field(
        8, betterproto2.TYPE_UINT64, optional=True, group="type"
    )

    bit_field: "bytes | None" = betterproto2.field(
        9, betterproto2.TYPE_BYTES, optional=True, group="type"
    )

    enum: "int | None" = betterproto2.field(
        10, betterproto2.TYPE_UINT32, optional=True, group="type"
    )

    empty: "___google__protobuf__.Empty | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )
    """
    If there's not a new data point for a channel at the given timestamp, pass empty to skip it
    """


default_message_pool.register_message(
    "sift.ingest.v1",
    "IngestWithConfigDataChannelValue",
    IngestWithConfigDataChannelValue,
)


@dataclass(eq=False, repr=False)
class IngestWithConfigDataStreamRequest(betterproto2.Message):
    ingestion_config_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    flow: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    timestamp: "datetime.datetime | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    channel_values: "list[IngestWithConfigDataChannelValue]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    run_id: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    The run_id MUST be included if this data is part of a run.
    """

    end_stream_on_validation_error: "bool" = betterproto2.field(
        6, betterproto2.TYPE_BOOL
    )
    """
    By default, if this request contains any channel values that do not match
    the supplied ingestion config, the request is stored in an error queue and
    the stream continues to accept data. This ensures all data is saved, but
    only valid data is fully ingested. If this is set to `true`, any validation
    errors end the stream and return the error to the client.
    """

    organization_id: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "sift.ingest.v1",
    "IngestWithConfigDataStreamRequest",
    IngestWithConfigDataStreamRequest,
)


@dataclass(eq=False, repr=False)
class IngestWithConfigDataStreamResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "sift.ingest.v1",
    "IngestWithConfigDataStreamResponse",
    IngestWithConfigDataStreamResponse,
)


class IngestServiceStub:
    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def ingest_with_config_data_stream(
        self, messages: "Iterable[IngestWithConfigDataStreamRequest]"
    ) -> "IngestWithConfigDataStreamResponse":
        return self._channel.stream_unary(
            "/sift.ingest.v1.IngestService/IngestWithConfigDataStream",
            IngestWithConfigDataStreamRequest.SerializeToString,
            IngestWithConfigDataStreamResponse.FromString,
        )(iter(messages))

    def ingest_arbitrary_protobuf_data_stream(
        self, messages: "Iterable[IngestArbitraryProtobufDataStreamRequest]"
    ) -> "IngestArbitraryProtobufDataStreamResponse":
        return self._channel.stream_unary(
            "/sift.ingest.v1.IngestService/IngestArbitraryProtobufDataStream",
            IngestArbitraryProtobufDataStreamRequest.SerializeToString,
            IngestArbitraryProtobufDataStreamResponse.FromString,
        )(iter(messages))


class IngestServiceAsyncStub(betterproto2.ServiceStub):
    async def ingest_with_config_data_stream(
        self,
        messages: "AsyncIterable[IngestWithConfigDataStreamRequest] | Iterable[IngestWithConfigDataStreamRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "IngestWithConfigDataStreamResponse":
        return await self._stream_unary(
            "/sift.ingest.v1.IngestService/IngestWithConfigDataStream",
            messages,
            IngestWithConfigDataStreamRequest,
            IngestWithConfigDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def ingest_arbitrary_protobuf_data_stream(
        self,
        messages: "AsyncIterable[IngestArbitraryProtobufDataStreamRequest] | Iterable[IngestArbitraryProtobufDataStreamRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "IngestArbitraryProtobufDataStreamResponse":
        return await self._stream_unary(
            "/sift.ingest.v1.IngestService/IngestArbitraryProtobufDataStream",
            messages,
            IngestArbitraryProtobufDataStreamRequest,
            IngestArbitraryProtobufDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....google import protobuf as ___google__protobuf__


class IngestServiceBase(ServiceBase):
    async def ingest_with_config_data_stream(
        self, messages: "AsyncIterator[IngestWithConfigDataStreamRequest]"
    ) -> "IngestWithConfigDataStreamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def ingest_arbitrary_protobuf_data_stream(
        self, messages: "AsyncIterator[IngestArbitraryProtobufDataStreamRequest]"
    ) -> "IngestArbitraryProtobufDataStreamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_ingest_with_config_data_stream(
        self,
        stream: "grpclib.server.Stream[IngestWithConfigDataStreamRequest, IngestWithConfigDataStreamResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.ingest_with_config_data_stream(request)
        await stream.send_message(response)

    async def __rpc_ingest_arbitrary_protobuf_data_stream(
        self,
        stream: "grpclib.server.Stream[IngestArbitraryProtobufDataStreamRequest, IngestArbitraryProtobufDataStreamResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.ingest_arbitrary_protobuf_data_stream(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/sift.ingest.v1.IngestService/IngestWithConfigDataStream": grpclib.const.Handler(
                self.__rpc_ingest_with_config_data_stream,
                grpclib.const.Cardinality.STREAM_UNARY,
                IngestWithConfigDataStreamRequest,
                IngestWithConfigDataStreamResponse,
            ),
            "/sift.ingest.v1.IngestService/IngestArbitraryProtobufDataStream": grpclib.const.Handler(
                self.__rpc_ingest_arbitrary_protobuf_data_stream,
                grpclib.const.Cardinality.STREAM_UNARY,
                IngestArbitraryProtobufDataStreamRequest,
                IngestArbitraryProtobufDataStreamResponse,
            ),
        }
