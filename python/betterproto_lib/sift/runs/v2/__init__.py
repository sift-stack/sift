# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/runs/v2/runs.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Run(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    created_date: datetime = betterproto.message_field(2)
    modified_date: datetime = betterproto.message_field(3)
    created_by_user_id: str = betterproto.string_field(4)
    modified_by_user_id: str = betterproto.string_field(5)
    organization_id: str = betterproto.string_field(6)
    start_time: Optional[datetime] = betterproto.message_field(7, optional=True)
    stop_time: Optional[datetime] = betterproto.message_field(8, optional=True)
    is_pinned: bool = betterproto.bool_field(9)
    name: str = betterproto.string_field(10)
    description: str = betterproto.string_field(11)
    tags: List[str] = betterproto.string_field(12)
    default_report_id: str = betterproto.string_field(13)
    client_key: Optional[str] = betterproto.string_field(14, optional=True)


@dataclass(eq=False, repr=False)
class GetRunRequest(betterproto.Message):
    """The request for a call to `RunService_GetRun` to retrieve run."""

    run_id: str = betterproto.string_field(1)
    """The ID of the run to retrieve."""


@dataclass(eq=False, repr=False)
class GetRunResponse(betterproto.Message):
    """
    The response of a call to `RunService_GetRun` containing the requested run.
    """

    run: "Run" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListRunsRequest(betterproto.Message):
    """The request for a call to `RunService_ListRuns` to retrieve runs."""

    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of runs to return.
     The service may return fewer than this value.
     If unspecified, at most 50 runs will be returned.
     The maximum value is 1000; values above 1000 will be coerced to 1000.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListRuns` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListRuns` must match
     the call that provided the page token.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `run_id`, `organization_id`, `name`, `description`, `created_by_user_id`, `modified_by_user_id`,
     `created_date`, `modified_date`, `start_time`, `stop_time`, `client_key`, `is_pinned`, `asset_id`, `client_key`, and `asset_name`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/docs/api/grpc/protocol-buffers/runs#run). Optional.
    """

    order_by: str = betterproto.string_field(4)
    """
    How to order the retrieved runs. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date`, `modified_date`, `start_time`, and `stop_time`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date"
    """


@dataclass(eq=False, repr=False)
class ListRunsResponse(betterproto.Message):
    """
    The response of a call to `RunService_ListRuns` containing requested runs.
    """

    runs: List["Run"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CreateRunRequest(betterproto.Message):
    """
    The request of a call to `RunService_CreateRuns` to create a new run.
    """

    name: str = betterproto.string_field(1)
    """The name that will be assigned to the new run."""

    description: str = betterproto.string_field(2)
    """A description about the new run."""

    tags: List[str] = betterproto.string_field(3)
    """Tags to associate with the new run."""

    start_time: datetime = betterproto.message_field(4)
    """
    The time at which data ingestion begins for this new run. It must be before the `stop_time`, and it must
     be provided if a `stop_time` is provided.
     Important note: `start_time` will be automatically computed during data ingestion and will be set
     based on the timestamp of the data for this run.
    """

    stop_time: datetime = betterproto.message_field(5)
    """
    The time at which data ingestion for this new run concludes.
     Important note: `stop_time` will be automatically computed during data ingestion and will be
     set based on the timestamp of the data for this run.
    """

    organization_id: str = betterproto.string_field(7)
    """
    An organization ID is only required if the user belongs to multiple organizations.
    """

    client_key: Optional[str] = betterproto.string_field(8, optional=True)
    """
    An arbitrary user-chosen key that uniquely identifies this run. Optional, though it is recommended to provide.
    """


@dataclass(eq=False, repr=False)
class CreateRunResponse(betterproto.Message):
    """
    The response of a call to `RunService_CreateRuns` containing the newly created run.
    """

    run: "Run" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateRunRequest(betterproto.Message):
    """
    The request for a call to `RunService_UpdateRun` to update an existing run.
    """

    run: "Run" = betterproto.message_field(1)
    """
    The run to update. The run's `run_id` field is used to identify the run to update
     and is required.
    """

    update_mask: "betterproto_lib_google_protobuf.FieldMask" = (
        betterproto.message_field(2)
    )
    """
    The list of fields to be updated. The fields available to be updated are `name`, `description`,
     `start_time`, `stop_time`, `is_pinned`, `client_key`  and `tags`.
     Important Note: When updating the `start_time`, please be aware that if a subsequent data ingestion
     commences for this run, the `start_time` will be automatically overwritten and set to the timestamp
     corresponding to the beginning of the latest run. Additionally, `client_key` can only be set once either in run creation or in update.
     Any subsequent attempt to update `client_key` will result in an error.
    """


@dataclass(eq=False, repr=False)
class UpdateRunResponse(betterproto.Message):
    """
    The response of a call to `RunService_UpdateRun` containing the updated run.
    """

    run: "Run" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateAutomaticRunAssociationForAssetsRequest(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """The ID of the run to associate the asset with."""

    asset_names: List[str] = betterproto.string_field(2)
    """
    A list of asset names to automatically associate with the run.
     Any data that is received for these assets will automatically added to the run.
     This applies even if the run has concluded, so long as the new data contains
     timestamps that are between the `start_time` and `stop_time`.
     If any of the assets are already associated with a different run whose run
     period (the period between `start_time` and `end_time`) overlaps with the
     requested run period, an error will be returned.
    """


@dataclass(eq=False, repr=False)
class CreateAutomaticRunAssociationForAssetsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteRunRequest(betterproto.Message):
    """The request for a call to `RunService_DeleteRun`."""

    run_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteRunResponse(betterproto.Message):
    """The response of a call to `RunService_DeleteRun`."""

    pass


@dataclass(eq=False, repr=False)
class StopRunRequest(betterproto.Message):
    """The request for a call to `RunService_StopRun` to stop a run."""

    run_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class StopRunResponse(betterproto.Message):
    """The response of a call to `RunService_StopRun` to stop a run."""

    pass


class RunServiceStub(betterproto.ServiceStub):
    async def get_run(
        self,
        get_run_request: "GetRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetRunResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/GetRun",
            get_run_request,
            GetRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_runs(
        self,
        list_runs_request: "ListRunsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListRunsResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/ListRuns",
            list_runs_request,
            ListRunsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_run(
        self,
        create_run_request: "CreateRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateRunResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/CreateRun",
            create_run_request,
            CreateRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_run(
        self,
        update_run_request: "UpdateRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateRunResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/UpdateRun",
            update_run_request,
            UpdateRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_run(
        self,
        delete_run_request: "DeleteRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteRunResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/DeleteRun",
            delete_run_request,
            DeleteRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop_run(
        self,
        stop_run_request: "StopRunRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StopRunResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/StopRun",
            stop_run_request,
            StopRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_automatic_run_association_for_assets(
        self,
        create_automatic_run_association_for_assets_request: "CreateAutomaticRunAssociationForAssetsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateAutomaticRunAssociationForAssetsResponse":
        return await self._unary_unary(
            "/sift.runs.v2.RunService/CreateAutomaticRunAssociationForAssets",
            create_automatic_run_association_for_assets_request,
            CreateAutomaticRunAssociationForAssetsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RunServiceBase(ServiceBase):

    async def get_run(self, get_run_request: "GetRunRequest") -> "GetRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_runs(
        self, list_runs_request: "ListRunsRequest"
    ) -> "ListRunsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_run(
        self, create_run_request: "CreateRunRequest"
    ) -> "CreateRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_run(
        self, update_run_request: "UpdateRunRequest"
    ) -> "UpdateRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_run(
        self, delete_run_request: "DeleteRunRequest"
    ) -> "DeleteRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop_run(self, stop_run_request: "StopRunRequest") -> "StopRunResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_automatic_run_association_for_assets(
        self,
        create_automatic_run_association_for_assets_request: "CreateAutomaticRunAssociationForAssetsRequest",
    ) -> "CreateAutomaticRunAssociationForAssetsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_run(
        self, stream: "grpclib.server.Stream[GetRunRequest, GetRunResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_run(request)
        await stream.send_message(response)

    async def __rpc_list_runs(
        self, stream: "grpclib.server.Stream[ListRunsRequest, ListRunsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_runs(request)
        await stream.send_message(response)

    async def __rpc_create_run(
        self, stream: "grpclib.server.Stream[CreateRunRequest, CreateRunResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_run(request)
        await stream.send_message(response)

    async def __rpc_update_run(
        self, stream: "grpclib.server.Stream[UpdateRunRequest, UpdateRunResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_run(request)
        await stream.send_message(response)

    async def __rpc_delete_run(
        self, stream: "grpclib.server.Stream[DeleteRunRequest, DeleteRunResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_run(request)
        await stream.send_message(response)

    async def __rpc_stop_run(
        self, stream: "grpclib.server.Stream[StopRunRequest, StopRunResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop_run(request)
        await stream.send_message(response)

    async def __rpc_create_automatic_run_association_for_assets(
        self,
        stream: "grpclib.server.Stream[CreateAutomaticRunAssociationForAssetsRequest, CreateAutomaticRunAssociationForAssetsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_automatic_run_association_for_assets(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.runs.v2.RunService/GetRun": grpclib.const.Handler(
                self.__rpc_get_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRunRequest,
                GetRunResponse,
            ),
            "/sift.runs.v2.RunService/ListRuns": grpclib.const.Handler(
                self.__rpc_list_runs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListRunsRequest,
                ListRunsResponse,
            ),
            "/sift.runs.v2.RunService/CreateRun": grpclib.const.Handler(
                self.__rpc_create_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateRunRequest,
                CreateRunResponse,
            ),
            "/sift.runs.v2.RunService/UpdateRun": grpclib.const.Handler(
                self.__rpc_update_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRunRequest,
                UpdateRunResponse,
            ),
            "/sift.runs.v2.RunService/DeleteRun": grpclib.const.Handler(
                self.__rpc_delete_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRunRequest,
                DeleteRunResponse,
            ),
            "/sift.runs.v2.RunService/StopRun": grpclib.const.Handler(
                self.__rpc_stop_run,
                grpclib.const.Cardinality.UNARY_UNARY,
                StopRunRequest,
                StopRunResponse,
            ),
            "/sift.runs.v2.RunService/CreateAutomaticRunAssociationForAssets": grpclib.const.Handler(
                self.__rpc_create_automatic_run_association_for_assets,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateAutomaticRunAssociationForAssetsRequest,
                CreateAutomaticRunAssociationForAssetsResponse,
            ),
        }
