# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/data/v1/data.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...calculated_channels import v1 as __calculated_channels_v1__
from ...common.type import v1 as __common_type_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class GetDataRequest(betterproto.Message):
    queries: List["Query"] = betterproto.message_field(1)
    start_time: datetime = betterproto.message_field(2)
    """
    Required. The starting timestamp of the data to retrieve. This is an inclusive bound.
    """

    end_time: datetime = betterproto.message_field(3)
    """
    Required. The end timestamp of the data to retrieve. This is an exclusive bound.
    """

    sample_ms: int = betterproto.uint32_field(4)
    """
    The rate to sample the returned data at. The data is sampled using [LTTB](https://github.com/sveinn-steinarsson/flot-downsample)
     which will return one point approximately every sample_ms milliseconds that retains the shape of the raw data.
     Sampling is only supported for numeric data types, if sample_ms is provided for non-numeric data, it will be
     ignored and the full-fidelity data will be returned.
    """

    page_size: int = betterproto.uint32_field(5)
    """
    The maximum number of channel values to return.
     The service may return fewer than this value.
     If unspecified, at most 10,000 values will be returned.
     The maximum value is 100,000; values above 100,000 will be coerced to 100,000.
     For variable data types (i.e. string channels), at most page_size elements
     will be read, or 1MB, whichever occurs first.
    """

    page_token: str = betterproto.string_field(6)
    """
    A page token, received from a previous `GetData` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `GetData` must match
     the call that provided the page token.
    """


@dataclass(eq=False, repr=False)
class Query(betterproto.Message):
    channel: "ChannelQuery" = betterproto.message_field(1, group="query")
    calculated_channel: "CalculatedChannelQuery" = betterproto.message_field(
        2, group="query"
    )


@dataclass(eq=False, repr=False)
class ChannelQuery(betterproto.Message):
    channel_id: str = betterproto.string_field(1)
    """channel_id is the uuid of the channel."""

    run_id: Optional[str] = betterproto.string_field(2, optional=True)
    """
    Optional.
     If set, only data associated with the specified run is returned.
     If set to the empty string, only non-run data is returned.
     If unset, all run / non-run data is returned.
    """


@dataclass(eq=False, repr=False)
class CalculatedChannelQuery(betterproto.Message):
    channel_key: str = betterproto.string_field(1)
    expression: "__calculated_channels_v1__.ExpressionRequest" = (
        betterproto.message_field(2)
    )
    run_id: Optional[str] = betterproto.string_field(3, optional=True)
    """
    Optional.
     If set, only data for the specified run is returned
     If set to the empty string, only non-run data is returned.
     If unset, all run / non-run data is returned.
    """

    mode: Optional["__calculated_channels_v1__.ExpressionMode"] = (
        betterproto.enum_field(4, optional=True)
    )
    """
    Optional. If unset, will default to EXPRESSION_MODE_CALCULATED_CHANNELS.
    """


@dataclass(eq=False, repr=False)
class GetDataResponse(betterproto.Message):
    next_page_token: str = betterproto.string_field(1)
    data: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(2)
    """
    data contains the result of the supplied queries.
     Be aware that each query can generate multiple data responses.
     For example, if run_id is omitted from a ChannelQuery, the query returns
     data for all runs containing that channel. Channel data for each run is
     returned in a separate data object.
     Possible message types:
       sift.data.v1.DoubleValues
       sift.data.v1.FloatValues
       sift.data.v1.StringValues
       sift.data.v1.EnumValues
       sift.data.v1.BitFieldValues
       sift.data.v1.BoolValues
       sift.data.v1.Int32Values
       sift.data.v1.Int64Values
       sift.data.v1.Uint32Values
       sift.data.v1.Uint64Values
    """


@dataclass(eq=False, repr=False)
class Metadata(betterproto.Message):
    data_type: "__common_type_v1__.ChannelDataType" = betterproto.enum_field(1)
    sampled_ms: int = betterproto.uint32_field(2)
    asset: "MetadataAsset" = betterproto.message_field(3)
    run: Optional["MetadataRun"] = betterproto.message_field(4, optional=True)
    channel: Optional["MetadataChannel"] = betterproto.message_field(5, optional=True)


@dataclass(eq=False, repr=False)
class MetadataAsset(betterproto.Message):
    asset_id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MetadataRun(betterproto.Message):
    run_id: str = betterproto.string_field(1)
    """
    The run_id that was sent with the data during ingestion (if any).
     Note that this may be different from the run_id that was requested in the query.
    """

    name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MetadataChannel(betterproto.Message):
    channel_id: str = betterproto.string_field(1)
    """
    For channel queries, this will contain the requested backing channel id.
     For calculated channel queries, this will contain the requested channel key.
    """

    component: str = betterproto.string_field(2)
    name: str = betterproto.string_field(3)
    unit: "MetadataChannelUnit" = betterproto.message_field(4)
    enum_types: List["__common_type_v1__.ChannelEnumType"] = betterproto.message_field(
        5
    )
    bit_field_elements: List["__common_type_v1__.ChannelBitFieldElement"] = (
        betterproto.message_field(6)
    )


@dataclass(eq=False, repr=False)
class MetadataChannelUnit(betterproto.Message):
    name: str = betterproto.string_field(1)
    abbreviated_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DoubleValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: float = betterproto.double_field(2)


@dataclass(eq=False, repr=False)
class DoubleValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["DoubleValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class StringValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class StringValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["StringValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EnumValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class EnumValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["EnumValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class BitFieldValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class BitFieldElementValues(betterproto.Message):
    name: str = betterproto.string_field(1)
    values: List["BitFieldValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class BitFieldValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["BitFieldElementValues"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class BoolValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class BoolValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["BoolValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class FloatValue(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class FloatValues(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["FloatValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Int32Value(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.int32_field(2)


@dataclass(eq=False, repr=False)
class Int32Values(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["Int32Value"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Uint32Value(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class Uint32Values(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["Uint32Value"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Int64Value(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class Int64Values(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["Int64Value"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Uint64Value(betterproto.Message):
    timestamp: datetime = betterproto.message_field(1)
    value: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class Uint64Values(betterproto.Message):
    metadata: "Metadata" = betterproto.message_field(1)
    values: List["Uint64Value"] = betterproto.message_field(2)


class DataServiceStub(betterproto.ServiceStub):
    async def get_data(
        self,
        get_data_request: "GetDataRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDataResponse":
        return await self._unary_unary(
            "/sift.data.v1.DataService/GetData",
            get_data_request,
            GetDataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class DataServiceBase(ServiceBase):

    async def get_data(self, get_data_request: "GetDataRequest") -> "GetDataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_data(
        self, stream: "grpclib.server.Stream[GetDataRequest, GetDataResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_data(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.data.v1.DataService/GetData": grpclib.const.Handler(
                self.__rpc_get_data,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDataRequest,
                GetDataResponse,
            ),
        }
