# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/protobuf_descriptors/v2/channel_parsing_options.proto, sift/protobuf_descriptors/v2/protobuf_descriptors.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class TagSourceType(betterproto.Enum):
    """Enum for different types of tag sources"""

    DESCENDANT_SOURCES = 0
    SIBLING_SOURCES = 1
    DESCENDANT_AND_SIBLING_SOURCES = 2


class TagTargetType(betterproto.Enum):
    """Enum for different types of tag targets"""

    ANCESTOR_TARGETS = 0
    SIBLING_TARGETS = 1
    ANCESTOR_AND_SIBLING_TARGETS = 2


class MapKeyOverrideType(betterproto.Enum):
    """Enum for the source and destination of a map key override"""

    MAP_KEY_OVERRIDE_UNSPECIFIED = 0
    MAP_KEY_OVERRIDE_TARGET = 1
    MAP_KEY_OVERRIDE_SOURCE = 2
    MAP_KEY_OVERRIDE_REMOVE_KEY = 3
    MAP_KEY_OVERRIDE_ENUM = 4


class ArrayIndexOverrideType(betterproto.Enum):
    """Enum for the source and destination of an array index override"""

    ARRAY_INDEX_OVERRIDE_UNSPECIFIED = 0
    ARRAY_INDEX_OVERRIDE_TARGET = 1
    ARRAY_INDEX_OVERRIDE_SOURCE = 2
    ARRAY_INDEX_OVERRIDE_REMOVE_INDEX = 3
    ARRAY_INDEX_OVERRIDE_ENUM = 4


class BytesDecodingType(betterproto.Enum):
    """Enum for how to decode bytes fields"""

    UNSPECIFIED = 0
    UTF8 = 1


@dataclass(eq=False, repr=False)
class TagTarget(betterproto.Message):
    """Message representing a tag target"""

    allowed_tag_source: Optional["TagSourceType"] = betterproto.enum_field(
        1, optional=True
    )
    """
    Setting this value indicates the allowed sources for tag values.
     If set to SIBLING_SOURCES, tag_sources from descendant proto fields will not be applied.
     If set to DESCENDANT_SOURCES, sibling tag_sources will not be applied.
    """


@dataclass(eq=False, repr=False)
class TagSource(betterproto.Message):
    """Message representing a tag source"""

    allowed_tag_target: Optional["TagTargetType"] = betterproto.enum_field(
        1, optional=True
    )
    """
    Indicates which tag_target relationships are allowed to have this tag.
     If set to ANCESTOR_TARGETS, sibling tag_targets will not have this value.
     If set to SIBLING_TARGETS, it will not apply to tag_targets that are ancestors.
    """

    tag_name: Optional[str] = betterproto.string_field(2, optional=True)
    """
    The name of the tag. It defaults to the field name but can be overridden here.
    """


@dataclass(eq=False, repr=False)
class DeleteProtobufDescriptorsRequest(betterproto.Message):
    message_type_full_name: str = betterproto.string_field(1)
    namespace: str = betterproto.string_field(2)
    organization_id: str = betterproto.string_field(3)
    protobuf_descriptor_id: str = betterproto.string_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("message_type_full_name"):
            warnings.warn(
                "DeleteProtobufDescriptorsRequest.message_type_full_name is deprecated",
                DeprecationWarning,
            )
        if self.is_set("namespace"):
            warnings.warn(
                "DeleteProtobufDescriptorsRequest.namespace is deprecated",
                DeprecationWarning,
            )


@dataclass(eq=False, repr=False)
class DeleteProtobufDescriptorsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AddProtobufDescriptorRequest(betterproto.Message):
    protobuf_descriptor: "ProtobufDescriptor" = betterproto.message_field(1)
    force_duplicate_registration: bool = betterproto.bool_field(2)
    """
    If set to true, the service will ignore checks that this descriptor has already been registered
     and will ensure that it is registered as the latest proto descriptor for the message type.
    """


@dataclass(eq=False, repr=False)
class AddProtobufDescriptorResponse(betterproto.Message):
    protobuf_descriptor: "ProtobufDescriptor" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ProtobufDescriptor(betterproto.Message):
    message_type_full_name: str = betterproto.string_field(1)
    file_descriptor_set: bytes = betterproto.bytes_field(2)
    proto_file_name: str = betterproto.string_field(3)
    namespace: str = betterproto.string_field(4)
    protobuf_descriptor_id: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class ListProtobufDescriptorsRequest(betterproto.Message):
    """
    The request for a call to `ProtobufDescriptorService_ListProtobufDescriptors` to retrieve protobuf descriptors.
    """

    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of protobuf descriptors to return.
     The service may return fewer than this value.
     If unspecified, at most 50 protobuf descriptors will be returned.
     The maximum value is 1000; values above 1000 will be coerced to 1000.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListProtobufDescriptors` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListProtobufDescriptors` must match
     the call that provided the page token.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `protobuf_descriptor_id`, `proto_file_name`, `namespace`, and `message_type_full_name`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/protocol-buffers/documentation#protobufdescriptor). Optional.
    """

    order_by: str = betterproto.string_field(4)
    """
    How to order the retrieved protobuf descriptors. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date`, `modified_date`, and `message_type_full_name` and `namespace`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date"
    """


@dataclass(eq=False, repr=False)
class ListProtobufDescriptorsResponse(betterproto.Message):
    """
    The response of a call to `ProtobufDescriptorService_ListProtobufDescriptors`.
    """

    protobuf_descriptors: List["ProtobufDescriptor"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


class ProtobufDescriptorServiceStub(betterproto.ServiceStub):
    async def add_protobuf_descriptor(
        self,
        add_protobuf_descriptor_request: "AddProtobufDescriptorRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AddProtobufDescriptorResponse":
        return await self._unary_unary(
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/AddProtobufDescriptor",
            add_protobuf_descriptor_request,
            AddProtobufDescriptorResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_protobuf_descriptors(
        self,
        delete_protobuf_descriptors_request: "DeleteProtobufDescriptorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteProtobufDescriptorsResponse":
        return await self._unary_unary(
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/DeleteProtobufDescriptors",
            delete_protobuf_descriptors_request,
            DeleteProtobufDescriptorsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_protobuf_descriptors(
        self,
        list_protobuf_descriptors_request: "ListProtobufDescriptorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListProtobufDescriptorsResponse":
        return await self._unary_unary(
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/ListProtobufDescriptors",
            list_protobuf_descriptors_request,
            ListProtobufDescriptorsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ProtobufDescriptorServiceBase(ServiceBase):

    async def add_protobuf_descriptor(
        self, add_protobuf_descriptor_request: "AddProtobufDescriptorRequest"
    ) -> "AddProtobufDescriptorResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_protobuf_descriptors(
        self, delete_protobuf_descriptors_request: "DeleteProtobufDescriptorsRequest"
    ) -> "DeleteProtobufDescriptorsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_protobuf_descriptors(
        self, list_protobuf_descriptors_request: "ListProtobufDescriptorsRequest"
    ) -> "ListProtobufDescriptorsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_add_protobuf_descriptor(
        self,
        stream: "grpclib.server.Stream[AddProtobufDescriptorRequest, AddProtobufDescriptorResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_protobuf_descriptor(request)
        await stream.send_message(response)

    async def __rpc_delete_protobuf_descriptors(
        self,
        stream: "grpclib.server.Stream[DeleteProtobufDescriptorsRequest, DeleteProtobufDescriptorsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_protobuf_descriptors(request)
        await stream.send_message(response)

    async def __rpc_list_protobuf_descriptors(
        self,
        stream: "grpclib.server.Stream[ListProtobufDescriptorsRequest, ListProtobufDescriptorsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_protobuf_descriptors(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/AddProtobufDescriptor": grpclib.const.Handler(
                self.__rpc_add_protobuf_descriptor,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddProtobufDescriptorRequest,
                AddProtobufDescriptorResponse,
            ),
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/DeleteProtobufDescriptors": grpclib.const.Handler(
                self.__rpc_delete_protobuf_descriptors,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteProtobufDescriptorsRequest,
                DeleteProtobufDescriptorsResponse,
            ),
            "/sift.protobuf_descriptors.v2.ProtobufDescriptorService/ListProtobufDescriptors": grpclib.const.Handler(
                self.__rpc_list_protobuf_descriptors,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListProtobufDescriptorsRequest,
                ListProtobufDescriptorsResponse,
            ),
        }
