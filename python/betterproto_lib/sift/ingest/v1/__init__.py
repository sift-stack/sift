# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/ingest/v1/ingest.proto
# plugin: python-betterproto
# This file has been @generated
import builtins
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class IngestWithConfigDataStreamRequest(betterproto.Message):
    ingestion_config_id: str = betterproto.string_field(1)
    flow: str = betterproto.string_field(2)
    timestamp: datetime = betterproto.message_field(3)
    channel_values: List["IngestWithConfigDataChannelValue"] = (
        betterproto.message_field(4)
    )
    run_id: str = betterproto.string_field(5)
    """The run_id MUST be included if this data is part of a run."""

    end_stream_on_validation_error: bool = betterproto.bool_field(6)
    """
    By default, if this request contains any channel values that do not match
     the supplied ingestion config, the request is stored in an error queue and
     the stream continues to accept data. This ensures all data is saved, but
     only valid data is fully ingested. If this is set to `true`, any validation
     errors end the stream and return the error to the client.
    """

    organization_id: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class IngestWithConfigDataStreamResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class IngestWithConfigDataChannelValue(betterproto.Message):
    string: str = betterproto.string_field(1, group="type")
    double: float = betterproto.double_field(2, group="type")
    float: builtins.float = betterproto.float_field(3, group="type")
    bool: builtins.bool = betterproto.bool_field(4, group="type")
    int32: int = betterproto.int32_field(5, group="type")
    uint32: int = betterproto.uint32_field(6, group="type")
    int64: int = betterproto.int64_field(7, group="type")
    uint64: int = betterproto.uint64_field(8, group="type")
    bit_field: bytes = betterproto.bytes_field(9, group="type")
    enum: int = betterproto.uint32_field(10, group="type")
    empty: "betterproto_lib_google_protobuf.Empty" = betterproto.message_field(
        11, group="type"
    )
    """
    If there's not a new data point for a channel at the given timestamp, pass empty to skip it
    """


@dataclass(eq=False, repr=False)
class IngestArbitraryProtobufDataStreamRequest(betterproto.Message):
    message_type_identifier: str = betterproto.string_field(1)
    message_type_display_name: Optional[str] = betterproto.string_field(
        2, optional=True
    )
    asset_name: str = betterproto.string_field(3)
    timestamp: datetime = betterproto.message_field(4)
    value: bytes = betterproto.bytes_field(5)
    run_id: str = betterproto.string_field(6)
    namespace: str = betterproto.string_field(7)
    organization_id: str = betterproto.string_field(8)
    end_stream_on_validation_error: bool = betterproto.bool_field(9)
    """
    By default, if this request fails to parse for any reason, the request is 
     stored in an error queue and the stream continues to accept data. This 
     ensures all data is saved, but only valid data is fully ingested. If this 
     is set to `true`, any validation errors end the stream and return the error to the client.
    """


@dataclass(eq=False, repr=False)
class IngestArbitraryProtobufDataStreamResponse(betterproto.Message):
    pass


class IngestServiceStub(betterproto.ServiceStub):
    async def ingest_with_config_data_stream(
        self,
        ingest_with_config_data_stream_request_iterator: Union[
            AsyncIterable[IngestWithConfigDataStreamRequest],
            Iterable[IngestWithConfigDataStreamRequest],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IngestWithConfigDataStreamResponse":
        return await self._stream_unary(
            "/sift.ingest.v1.IngestService/IngestWithConfigDataStream",
            ingest_with_config_data_stream_request_iterator,
            IngestWithConfigDataStreamRequest,
            IngestWithConfigDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def ingest_arbitrary_protobuf_data_stream(
        self,
        ingest_arbitrary_protobuf_data_stream_request_iterator: Union[
            AsyncIterable[IngestArbitraryProtobufDataStreamRequest],
            Iterable[IngestArbitraryProtobufDataStreamRequest],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IngestArbitraryProtobufDataStreamResponse":
        return await self._stream_unary(
            "/sift.ingest.v1.IngestService/IngestArbitraryProtobufDataStream",
            ingest_arbitrary_protobuf_data_stream_request_iterator,
            IngestArbitraryProtobufDataStreamRequest,
            IngestArbitraryProtobufDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class IngestServiceBase(ServiceBase):

    async def ingest_with_config_data_stream(
        self,
        ingest_with_config_data_stream_request_iterator: AsyncIterator[
            IngestWithConfigDataStreamRequest
        ],
    ) -> "IngestWithConfigDataStreamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def ingest_arbitrary_protobuf_data_stream(
        self,
        ingest_arbitrary_protobuf_data_stream_request_iterator: AsyncIterator[
            IngestArbitraryProtobufDataStreamRequest
        ],
    ) -> "IngestArbitraryProtobufDataStreamResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_ingest_with_config_data_stream(
        self,
        stream: "grpclib.server.Stream[IngestWithConfigDataStreamRequest, IngestWithConfigDataStreamResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.ingest_with_config_data_stream(request)
        await stream.send_message(response)

    async def __rpc_ingest_arbitrary_protobuf_data_stream(
        self,
        stream: "grpclib.server.Stream[IngestArbitraryProtobufDataStreamRequest, IngestArbitraryProtobufDataStreamResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.ingest_arbitrary_protobuf_data_stream(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.ingest.v1.IngestService/IngestWithConfigDataStream": grpclib.const.Handler(
                self.__rpc_ingest_with_config_data_stream,
                grpclib.const.Cardinality.STREAM_UNARY,
                IngestWithConfigDataStreamRequest,
                IngestWithConfigDataStreamResponse,
            ),
            "/sift.ingest.v1.IngestService/IngestArbitraryProtobufDataStream": grpclib.const.Handler(
                self.__rpc_ingest_arbitrary_protobuf_data_stream,
                grpclib.const.Cardinality.STREAM_UNARY,
                IngestArbitraryProtobufDataStreamRequest,
                IngestArbitraryProtobufDataStreamResponse,
            ),
        }
