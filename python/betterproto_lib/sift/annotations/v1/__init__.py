# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/annotations/v1/annotations.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class AnnotationState(betterproto.Enum):
    UNSPECIFIED = 0
    OPEN = 1
    FLAGGED = 2
    RESOLVED = 3


class AnnotationType(betterproto.Enum):
    UNSPECIFIED = 0
    DATA_REVIEW = 1
    PHASE = 2


@dataclass(eq=False, repr=False)
class Annotation(betterproto.Message):
    annotation_id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    start_time: datetime = betterproto.message_field(4)
    end_time: datetime = betterproto.message_field(5)
    created_by_user_id: str = betterproto.string_field(6)
    modified_by_user_id: str = betterproto.string_field(7)
    created_date: datetime = betterproto.message_field(8)
    modified_date: datetime = betterproto.message_field(9)
    run_id: Optional[str] = betterproto.string_field(10, optional=True)
    state: Optional["AnnotationState"] = betterproto.enum_field(11, optional=True)
    organization_id: str = betterproto.string_field(12)
    assigned_to_user_id: str = betterproto.string_field(13)
    annotation_type: "AnnotationType" = betterproto.enum_field(14)
    tags: List[str] = betterproto.string_field(15)
    legend_config: Optional[str] = betterproto.string_field(16, optional=True)
    created_by_condition_id: Optional[str] = betterproto.string_field(17, optional=True)
    created_by_rule_condition_version_id: Optional[str] = betterproto.string_field(
        18, optional=True
    )
    report_rule_version_id: Optional[str] = betterproto.string_field(19, optional=True)
    pending: bool = betterproto.bool_field(20)
    """
    An annotation is pending if it is part of an ongoing violation of a rule condition.
     The `end_time` of a pending annotation might be set, but is not yet finalized.
    """


@dataclass(eq=False, repr=False)
class AnnotationLinkedChannelsChannel(betterproto.Message):
    channel_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class AnnotationLinkedChannelsBitFieldElement(betterproto.Message):
    channel_id: str = betterproto.string_field(1)
    bit_field_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class AnnotationLinkedChannel(betterproto.Message):
    channel: "AnnotationLinkedChannelsChannel" = betterproto.message_field(
        1, group="type"
    )
    bit_field_element: "AnnotationLinkedChannelsBitFieldElement" = (
        betterproto.message_field(2, group="type")
    )


@dataclass(eq=False, repr=False)
class CreateAnnotationRequest(betterproto.Message):
    """
    The request for a call to `AnnotationService_CreateAnnotation` to create a new annotation.
     At least 1 asset, tag, or channel must be specified.
    """

    name: str = betterproto.string_field(1)
    """The name assigned to the new annotation."""

    description: str = betterproto.string_field(2)
    """A short description about the new annotation."""

    start_time: datetime = betterproto.message_field(3)
    """When the annotation starts."""

    end_time: datetime = betterproto.message_field(4)
    """When the annotation ends."""

    assets: List[str] = betterproto.string_field(5)
    """The names of the assets to associate with this annotation."""

    linked_channels: List["AnnotationLinkedChannel"] = betterproto.message_field(6)
    """The channels to associate with this annotation."""

    tags: List[str] = betterproto.string_field(7)
    """The names of the tags to associate with this annotation."""

    run_id: Optional[str] = betterproto.string_field(8, optional=True)
    """The ID of the run that this annotation is associated with."""

    assign_to_user_id: Optional[str] = betterproto.string_field(9, optional=True)
    """The ID of the user that this annotation is assigned to."""

    organization_id: str = betterproto.string_field(10)
    """
    The organization associated with this annotation. An organization ID is only required
     if the user belongs to multiple organizations.
    """

    state: Optional["AnnotationState"] = betterproto.enum_field(11, optional=True)
    """
    The state of the annotation. If an annotation has an `annotation_type` of `ANNOTATION_TYPE_PHASE`, then state must be
     unset, otherwise an error will be returned.
    """

    annotation_type: "AnnotationType" = betterproto.enum_field(12)
    """The type of the annotation."""

    created_by_condition_id: Optional[str] = betterproto.string_field(14, optional=True)
    """The ID of the rule condition that created this annotation."""

    legend_config: Optional[str] = betterproto.string_field(13, optional=True)
    """
    A JSON string containing the axes configuration of the annotation's linked channels.
    """

    created_by_rule_condition_version_id: Optional[str] = betterproto.string_field(
        15, optional=True
    )
    """The ID of the rule condition version that created this annotation."""


@dataclass(eq=False, repr=False)
class CreateAnnotationResponse(betterproto.Message):
    """The result of a call to `AnnotationService_CreateAnnotation`."""

    annotation: "Annotation" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DeleteAnnotationRequest(betterproto.Message):
    """The request for a call to `AnnotationService_DeleteAnnotation`."""

    annotation_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteAnnotationResponse(betterproto.Message):
    """The response of a call to `AnnotationService_DeleteAnnotation`."""

    pass


@dataclass(eq=False, repr=False)
class BatchDeleteAnnotationsRequest(betterproto.Message):
    annotation_ids: List[str] = betterproto.string_field(1)
    """Limit of 1000 annotations per batch"""


@dataclass(eq=False, repr=False)
class BatchDeleteAnnotationsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetAnnotationRequest(betterproto.Message):
    """The request for a call to `AnnotationService_GetAnnotation`."""

    annotation_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetAnnotationResponse(betterproto.Message):
    """The response of a call to `AnnotationService_GetAnnotation`."""

    annotation: "Annotation" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListAnnotationsRequest(betterproto.Message):
    """
    The request for a call to `AnnotationService_ListAnnotations` to retrieve annotations.
    """

    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of annotations to return. The service may return fewer than this value.
     If unspecified, at most 50 annotations will be returned. The maximum value is 1000; values above
     1000 will be coerced to 1000. Optional.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListAnnotations` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListAnnotations` must match
     the call that provided the page token. Optional.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `annotation_id`, `start_time`, `end_time`,
     `created_date`, `modified_date`, `run_id`, `name`, `description`, `state`, `created_by_user_id`, `created_by_rule_condition_version_id`,
     `annotation_type`, `tag_name`, `report_id`, `asset_id`, `asset_name`, `pending`, and `assignee`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/docs/api/grpc/protocol-buffers/annotations#annotation). Optional.
    """

    organization_id: str = betterproto.string_field(4)
    """
    This field is only required if your user belongs to multiple organizations.
    """

    order_by: str = betterproto.string_field(5)
    """
    How to order the retrieved annotations. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date`, `modified_date`, `start_time`, and `end_time`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date"
    """


@dataclass(eq=False, repr=False)
class ListAnnotationsResponse(betterproto.Message):
    """The result of a call to `AnnotationService_ListAnnotations`."""

    annotations: List["Annotation"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(5)
    """
    Oops, we skipped to index 5! No reason for that; the indices between aren't reserved or anything.
    """


@dataclass(eq=False, repr=False)
class UpdateAnnotationRequest(betterproto.Message):
    """
    The request for a call to `AnnotationService_UpdateAnnotation` to update an annotation.
    """

    annotation: "Annotation" = betterproto.message_field(1)
    """The annotation to update."""

    update_mask: "betterproto_lib_google_protobuf.FieldMask" = (
        betterproto.message_field(2)
    )
    """
    The list of fields to be updated. The fields available to be updated are `name`, `description`, `start_time`,
     `end_time`, `assigned_to_user_id`, `state`, and `tags`.
     Important Note: if `tags` is specified in the update mask and `annotation.tags` is an empty list then all associated tags on the annotation
     will be removed.
    """


@dataclass(eq=False, repr=False)
class UpdateAnnotationResponse(betterproto.Message):
    """The response of a call to `AnnotationService_UpdateAnnotation`."""

    annotation: "Annotation" = betterproto.message_field(1)


class AnnotationServiceStub(betterproto.ServiceStub):
    async def create_annotation(
        self,
        create_annotation_request: "CreateAnnotationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateAnnotationResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/CreateAnnotation",
            create_annotation_request,
            CreateAnnotationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_annotation(
        self,
        delete_annotation_request: "DeleteAnnotationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteAnnotationResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/DeleteAnnotation",
            delete_annotation_request,
            DeleteAnnotationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_delete_annotations(
        self,
        batch_delete_annotations_request: "BatchDeleteAnnotationsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchDeleteAnnotationsResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/BatchDeleteAnnotations",
            batch_delete_annotations_request,
            BatchDeleteAnnotationsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_annotations(
        self,
        list_annotations_request: "ListAnnotationsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListAnnotationsResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/ListAnnotations",
            list_annotations_request,
            ListAnnotationsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_annotation(
        self,
        get_annotation_request: "GetAnnotationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetAnnotationResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/GetAnnotation",
            get_annotation_request,
            GetAnnotationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_annotation(
        self,
        update_annotation_request: "UpdateAnnotationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateAnnotationResponse":
        return await self._unary_unary(
            "/sift.annotations.v1.AnnotationService/UpdateAnnotation",
            update_annotation_request,
            UpdateAnnotationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AnnotationServiceBase(ServiceBase):

    async def create_annotation(
        self, create_annotation_request: "CreateAnnotationRequest"
    ) -> "CreateAnnotationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_annotation(
        self, delete_annotation_request: "DeleteAnnotationRequest"
    ) -> "DeleteAnnotationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_delete_annotations(
        self, batch_delete_annotations_request: "BatchDeleteAnnotationsRequest"
    ) -> "BatchDeleteAnnotationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_annotations(
        self, list_annotations_request: "ListAnnotationsRequest"
    ) -> "ListAnnotationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_annotation(
        self, get_annotation_request: "GetAnnotationRequest"
    ) -> "GetAnnotationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_annotation(
        self, update_annotation_request: "UpdateAnnotationRequest"
    ) -> "UpdateAnnotationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_annotation(
        self,
        stream: "grpclib.server.Stream[CreateAnnotationRequest, CreateAnnotationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_annotation(request)
        await stream.send_message(response)

    async def __rpc_delete_annotation(
        self,
        stream: "grpclib.server.Stream[DeleteAnnotationRequest, DeleteAnnotationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_annotation(request)
        await stream.send_message(response)

    async def __rpc_batch_delete_annotations(
        self,
        stream: "grpclib.server.Stream[BatchDeleteAnnotationsRequest, BatchDeleteAnnotationsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_delete_annotations(request)
        await stream.send_message(response)

    async def __rpc_list_annotations(
        self,
        stream: "grpclib.server.Stream[ListAnnotationsRequest, ListAnnotationsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_annotations(request)
        await stream.send_message(response)

    async def __rpc_get_annotation(
        self,
        stream: "grpclib.server.Stream[GetAnnotationRequest, GetAnnotationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_annotation(request)
        await stream.send_message(response)

    async def __rpc_update_annotation(
        self,
        stream: "grpclib.server.Stream[UpdateAnnotationRequest, UpdateAnnotationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_annotation(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.annotations.v1.AnnotationService/CreateAnnotation": grpclib.const.Handler(
                self.__rpc_create_annotation,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateAnnotationRequest,
                CreateAnnotationResponse,
            ),
            "/sift.annotations.v1.AnnotationService/DeleteAnnotation": grpclib.const.Handler(
                self.__rpc_delete_annotation,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteAnnotationRequest,
                DeleteAnnotationResponse,
            ),
            "/sift.annotations.v1.AnnotationService/BatchDeleteAnnotations": grpclib.const.Handler(
                self.__rpc_batch_delete_annotations,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchDeleteAnnotationsRequest,
                BatchDeleteAnnotationsResponse,
            ),
            "/sift.annotations.v1.AnnotationService/ListAnnotations": grpclib.const.Handler(
                self.__rpc_list_annotations,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListAnnotationsRequest,
                ListAnnotationsResponse,
            ),
            "/sift.annotations.v1.AnnotationService/GetAnnotation": grpclib.const.Handler(
                self.__rpc_get_annotation,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetAnnotationRequest,
                GetAnnotationResponse,
            ),
            "/sift.annotations.v1.AnnotationService/UpdateAnnotation": grpclib.const.Handler(
                self.__rpc_update_annotation,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateAnnotationRequest,
                UpdateAnnotationResponse,
            ),
        }
