# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/assets/v1/assets.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Asset(betterproto.Message):
    asset_id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    organization_id: str = betterproto.string_field(4)
    created_date: datetime = betterproto.message_field(5)
    created_by_user_id: str = betterproto.string_field(6)
    modified_date: datetime = betterproto.message_field(7)
    modified_by_user_id: str = betterproto.string_field(8)
    tags: List[str] = betterproto.string_field(9)
    """The names of the tags to associate with this asset."""


@dataclass(eq=False, repr=False)
class ListAssetsRequest(betterproto.Message):
    """The request for a call to `AssetService_ListAssets`."""

    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of assets to return.
     The service may return fewer than this value.
     If unspecified, at most 50 assets will be returned.
     The maximum value is 1000; values above 1000 will be coerced to 1000.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListAssets` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListAssets` must match
     the call that provided the page token.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `asset_id`, `created_by_user_id`, `modified_by_user_id`,
     `created_date`, `modified_date`, and `name`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/docs/api/grpc/protocol-buffers/assets#asset). Optional.
    """

    order_by: str = betterproto.string_field(4)
    """
    How to order the retrieved assets. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date` and `modified_date`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date"
    """


@dataclass(eq=False, repr=False)
class ListAssetsResponse(betterproto.Message):
    """The result of a call to `AssetService_ListAssets`."""

    assets: List["Asset"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class DeleteAssetRequest(betterproto.Message):
    """
    The request for a call to `AssetService_DeleteAsset` to delete a single existing annotation by its asset_id.
    """

    asset_id: str = betterproto.string_field(1)
    """The id of the asset to be deleted. Required."""


@dataclass(eq=False, repr=False)
class DeleteAssetResponse(betterproto.Message):
    """The response of a call to `AssetService_DeleteAsset`."""

    pass


@dataclass(eq=False, repr=False)
class GetAssetRequest(betterproto.Message):
    """
    The request for a call to `AssetService_GetAsset` to retrieve a single existing asset by its asset_id.
    """

    asset_id: str = betterproto.string_field(1)
    """The id of the asset to be retrieved. Required."""


@dataclass(eq=False, repr=False)
class GetAssetResponse(betterproto.Message):
    asset: "Asset" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateAssetRequest(betterproto.Message):
    asset: "Asset" = betterproto.message_field(1)
    """
    The asset to update. The asset's `asset_id` field is used to identify asset run to update
     and is required.
    """

    update_mask: "betterproto_lib_google_protobuf.FieldMask" = (
        betterproto.message_field(2)
    )
    """
    The list of fields to be updated. Currently, the only field available to be updated is `tags`.
    """


@dataclass(eq=False, repr=False)
class UpdateAssetResponse(betterproto.Message):
    asset: "Asset" = betterproto.message_field(1)


class AssetServiceStub(betterproto.ServiceStub):
    async def delete_asset(
        self,
        delete_asset_request: "DeleteAssetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteAssetResponse":
        return await self._unary_unary(
            "/sift.assets.v1.AssetService/DeleteAsset",
            delete_asset_request,
            DeleteAssetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_asset(
        self,
        get_asset_request: "GetAssetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetAssetResponse":
        return await self._unary_unary(
            "/sift.assets.v1.AssetService/GetAsset",
            get_asset_request,
            GetAssetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_assets(
        self,
        list_assets_request: "ListAssetsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListAssetsResponse":
        return await self._unary_unary(
            "/sift.assets.v1.AssetService/ListAssets",
            list_assets_request,
            ListAssetsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_asset(
        self,
        update_asset_request: "UpdateAssetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateAssetResponse":
        return await self._unary_unary(
            "/sift.assets.v1.AssetService/UpdateAsset",
            update_asset_request,
            UpdateAssetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AssetServiceBase(ServiceBase):

    async def delete_asset(
        self, delete_asset_request: "DeleteAssetRequest"
    ) -> "DeleteAssetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_asset(
        self, get_asset_request: "GetAssetRequest"
    ) -> "GetAssetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_assets(
        self, list_assets_request: "ListAssetsRequest"
    ) -> "ListAssetsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_asset(
        self, update_asset_request: "UpdateAssetRequest"
    ) -> "UpdateAssetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_delete_asset(
        self, stream: "grpclib.server.Stream[DeleteAssetRequest, DeleteAssetResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_asset(request)
        await stream.send_message(response)

    async def __rpc_get_asset(
        self, stream: "grpclib.server.Stream[GetAssetRequest, GetAssetResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_asset(request)
        await stream.send_message(response)

    async def __rpc_list_assets(
        self, stream: "grpclib.server.Stream[ListAssetsRequest, ListAssetsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_assets(request)
        await stream.send_message(response)

    async def __rpc_update_asset(
        self, stream: "grpclib.server.Stream[UpdateAssetRequest, UpdateAssetResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_asset(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.assets.v1.AssetService/DeleteAsset": grpclib.const.Handler(
                self.__rpc_delete_asset,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteAssetRequest,
                DeleteAssetResponse,
            ),
            "/sift.assets.v1.AssetService/GetAsset": grpclib.const.Handler(
                self.__rpc_get_asset,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetAssetRequest,
                GetAssetResponse,
            ),
            "/sift.assets.v1.AssetService/ListAssets": grpclib.const.Handler(
                self.__rpc_list_assets,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListAssetsRequest,
                ListAssetsResponse,
            ),
            "/sift.assets.v1.AssetService/UpdateAsset": grpclib.const.Handler(
                self.__rpc_update_asset,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateAssetRequest,
                UpdateAssetResponse,
            ),
        }
