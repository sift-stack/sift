# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/calculated_channels/v2/calculated_channels.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common.type import v1 as __common_type_v1__
from .. import v1 as _v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class CalculatedChannel(betterproto.Message):
    calculated_channel_id: str = betterproto.string_field(1)
    organization_id: str = betterproto.string_field(2)
    client_key: Optional[str] = betterproto.string_field(3, optional=True)
    archived_date: Optional[datetime] = betterproto.message_field(4, optional=True)
    version_id: str = betterproto.string_field(5)
    version: int = betterproto.uint32_field(6)
    name: str = betterproto.string_field(7)
    description: str = betterproto.string_field(8)
    change_message: str = betterproto.string_field(9)
    user_notes: str = betterproto.string_field(10)
    units: Optional[str] = betterproto.string_field(18, optional=True)
    created_date: datetime = betterproto.message_field(11)
    modified_date: datetime = betterproto.message_field(12)
    calculated_channel_configuration: "CalculatedChannelConfiguration" = (
        betterproto.message_field(15)
    )
    created_by_user_id: str = betterproto.string_field(16)
    modified_by_user_id: str = betterproto.string_field(17)


@dataclass(eq=False, repr=False)
class CalculatedChannelConfiguration(betterproto.Message):
    asset_configuration: "CalculatedChannelAssetConfiguration" = (
        betterproto.message_field(1)
    )
    query_configuration: "CalculatedChannelQueryConfiguration" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class CalculatedChannelAssetConfiguration(betterproto.Message):
    all_assets: bool = betterproto.bool_field(1, group="asset_scope")
    selection: "CalculatedChannelAssetConfigurationAssetSelection" = (
        betterproto.message_field(2, group="asset_scope")
    )


@dataclass(eq=False, repr=False)
class CalculatedChannelAssetConfigurationAssetSelection(betterproto.Message):
    asset_ids: List[str] = betterproto.string_field(1)
    tag_ids: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CalculatedChannelQueryConfiguration(betterproto.Message):
    sel: "CalculatedChannelQueryConfigurationSel" = betterproto.message_field(
        1, group="query"
    )


@dataclass(eq=False, repr=False)
class CalculatedChannelQueryConfigurationSel(betterproto.Message):
    """Sift Expression Language."""

    expression: str = betterproto.string_field(1)
    expression_channel_references: List["CalculatedChannelAbstractChannelReference"] = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class CalculatedChannelAbstractChannelReference(betterproto.Message):
    channel_reference: str = betterproto.string_field(1)
    channel_identifier: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CalculatedChannelValidationResult(betterproto.Message):
    asset_id: str = betterproto.string_field(1)
    asset_name: Optional[str] = betterproto.string_field(2, optional=True)
    """Only included if asset was named in the request"""

    tag_names: List[str] = betterproto.string_field(3)
    """Includes all tags that have this asset"""

    missing_channels: List[str] = betterproto.string_field(4)
    """Names of the channels that asset does not have"""


@dataclass(eq=False, repr=False)
class GetCalculatedChannelRequest(betterproto.Message):
    """
    The request for a call to `CalculatedChannelService_GetCalculatedChannel` to retrieve the latest version of a calculated channel.
     If `calculated_channel_id` is provided then all other arguments will be ignored. The argument `calculated_channel_id`
     should not be used together with `client_key`. The `organization_id` argument is only required
     if using `client_key` and the user belongs to multiple organizations.
    """

    calculated_channel_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)
    organization_id: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class GetCalculatedChannelResponse(betterproto.Message):
    calculated_channel: "CalculatedChannel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateCalculatedChannelRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    user_notes: str = betterproto.string_field(3)
    units: Optional[str] = betterproto.string_field(7, optional=True)
    client_key: Optional[str] = betterproto.string_field(4, optional=True)
    calculated_channel_configuration: "CalculatedChannelConfiguration" = (
        betterproto.message_field(5)
    )


@dataclass(eq=False, repr=False)
class CreateCalculatedChannelResponse(betterproto.Message):
    calculated_channel: "CalculatedChannel" = betterproto.message_field(1)
    inapplicable_assets: List["CalculatedChannelValidationResult"] = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ListCalculatedChannelsRequest(betterproto.Message):
    """
    The request for a call to `CalculatedChannelService_ListCalculatedChannels` to retrieve latest versions of calculated channels.
    """

    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of calculated channels to return. The service may return fewer than this value.
     If unspecified, at most 50 calculated channels will be returned. The maximum value is 1000; values above
     1000 will be coerced to 1000. Optional.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListCalculatedChannels` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListCalculatedChannels` must match
     the call that provided the page token. Optional.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `calculated_channel_id`, `client_key`, `name`, `asset_id`, `asset_name`, `tag_id`, `tag_name`, `version`, and `archived_date.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/docs/api/grpc/protocol-buffers/calculated_channels#calculated_channel). Optional.
    """

    organization_id: str = betterproto.string_field(4)
    """
    This field is only required if your user belongs to multiple organizations.
    """

    order_by: str = betterproto.string_field(5)
    """
    How to order the retrieved calculated channels. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date` and `modified_date`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date"
    """


@dataclass(eq=False, repr=False)
class ListCalculatedChannelsResponse(betterproto.Message):
    """
    The response of a call to `CalculatedChannelService_ListCalculatedChannels`.
    """

    calculated_channels: List["CalculatedChannel"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateCalculatedChannelRequest(betterproto.Message):
    """
    The request for a call to `CalculatedChannelService_UpdateCalculatedChannel` to update a calculated channel. Updating a calculated
     channel creates a new version of the calculated channel, leaving the previous untouched. If no update is deemed necessary, then the
     the current version is returned. To archive calculated channel, specify `archived_date` in the `update mask` as well as a non-null
     value for `archived_date` in the `calculated_channel` object. To unarchive a calculated channel, specify `archived_date` in the
     `update mask` and a `null` value for `archived_date` in the `calculated_channel` object.
    """

    calculated_channel: "CalculatedChannel" = betterproto.message_field(1)
    """The calculated channel to update."""

    update_mask: "betterproto_lib_google_protobuf.FieldMask" = (
        betterproto.message_field(2)
    )
    """
    The list of fields to be updated. The fields available to be updated are `name`, `description`, `units`,
     `query_configuration`, `archived_date`, and `asset_configuration`.
    """

    user_notes: Optional[str] = betterproto.string_field(3, optional=True)
    """Optional user notes to describe changes."""


@dataclass(eq=False, repr=False)
class UpdateCalculatedChannelResponse(betterproto.Message):
    """
    The response of a call to `CalculatedChannelService_UpdateCalculatedChannel`.
    """

    calculated_channel: "CalculatedChannel" = betterproto.message_field(1)
    inapplicable_assets: List["CalculatedChannelValidationResult"] = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ListCalculatedChannelVersionsRequest(betterproto.Message):
    """
    The request for a call to `CalculatedChannelService_ListCalculatedChannelVersions` to retrieve versions
     of a particular calculated channel. If `calculated_channel_id` is provided then `client_key` is ignored.
    """

    calculated_channel_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)
    page_size: int = betterproto.uint32_field(3)
    """
    The maximum number of calculated channel versions to return. The service may return fewer than this value.
     If unspecified, at most 50 calculated channels will be returned. The maximum value is 1000; values above
     1000 will be coerced to 1000. Optional.
    """

    page_token: str = betterproto.string_field(4)
    """
    A page token, received from a previous `ListCalculatedChannelVersions` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListCalculatedChannelVersions` must match
     the call that provided the page token. Optional.
    """

    filter: str = betterproto.string_field(5)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `calculated_channel_id`, `client_key`, `name`, `asset_id`, `asset_name`, `tag_id`, `tag_name`, `version`, and `archived_date.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     For more information about the fields used for filtering, please refer to [this definition](/docs/api/grpc/protocol-buffers/calculated_channels#calculated_channel). Optional.
    """

    organization_id: str = betterproto.string_field(6)
    """
    This field is only required if your user belongs to multiple organizations.
    """

    order_by: str = betterproto.string_field(7)
    """
    How to order the retrieved calculated channel versions. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date`, `modified_date`, and `version`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
     For more information about the format of this field, read [this](https://google.aip.dev/132#ordering)
     Example: "created_date desc,modified_date".
    """


@dataclass(eq=False, repr=False)
class ListCalculatedChannelVersionsResponse(betterproto.Message):
    """
    The response of a call to `CalculatedChannelService_ListCalculatedChannelVersions`.
    """

    calculated_channel_versions: List["CalculatedChannel"] = betterproto.message_field(
        1
    )
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ResolveCalculatedChannelRequest(betterproto.Message):
    """
    The request for a call to `CalculatedChannelService_ResolveCalculatedChannel` to get the all possible calculated channels.
     1) If the calculated channel has a selection of assets and tags then those assets will be used as a base and then filtered down by the given assets and assets from the run.
     2) If the calculated channel is enabled for all assets then:
       a) If the request has run and assets from the run will be used as a base and then filtered down by the given assets.
       b) If the request has run and no assets then those assets will be used.
       c) If the request has only assets then those assets will be used.
     The `organization_id` argument is only required if using `client_key` and the user belongs to multiple organizations.
    """

    identifier: "__common_type_v1__.ResourceIdentifier" = betterproto.message_field(
        1, group="calculated_channel"
    )
    """The calculated channel to resolve."""

    calculated_channel_configuration: "CalculatedChannelConfiguration" = (
        betterproto.message_field(2, group="calculated_channel")
    )
    """A configuration for the calculated channel to resolve."""

    organization_id: str = betterproto.string_field(3)
    """
    This field is only required if your user belongs to multiple organizations.
    """

    assets: "__common_type_v1__.NamedResources" = betterproto.message_field(4)
    """Assets to be included or filtered through.  See above."""

    run: Optional["__common_type_v1__.ResourceIdentifier"] = betterproto.message_field(
        5, optional=True
    )
    """Run to get assets to be included or filtered through.  See above."""


@dataclass(eq=False, repr=False)
class ResolveCalculatedChannelResponse(betterproto.Message):
    """
    The response of a call to `CalculatedChannelService_ResolveCalculatedChannel`.
    """

    calculated_channel_id: Optional[str] = betterproto.string_field(1, optional=True)
    """If provided in the request, the calculated channel resolved."""

    resolved: List["ResolveCalculatedChannelResponseResolvedCalculatedChannel"] = (
        betterproto.message_field(2)
    )
    """All resolved calculated channels."""

    unresolved: List["ResolveCalculatedChannelResponseUnresolvedCalculatedChannel"] = (
        betterproto.message_field(3)
    )
    """All assets with any issues in resolution."""


@dataclass(eq=False, repr=False)
class ResolveCalculatedChannelResponseResolvedCalculatedChannel(betterproto.Message):
    """
    A specific calculated channel including the asset and exact channels to query.
    """

    asset_name: str = betterproto.string_field(1)
    """The name of the specific asset that was resolved."""

    expression_request: "_v1__.ExpressionRequest" = betterproto.message_field(2)
    """The expression resolved including channel references."""

    output_data_type: "__common_type_v1__.ChannelDataType" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ResolveCalculatedChannelResponseUnresolvedCalculatedChannel(betterproto.Message):
    """Any failure in resolution."""

    asset_name: str = betterproto.string_field(1)
    """The name of the specific asset that was not resolved."""

    error_message: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BatchResolveCalculatedChannelsRequest(betterproto.Message):
    """
    The request of a call to `CalculatedChannelService_BatchResolveCalculatedChannels`.
    """

    requests: List["ResolveCalculatedChannelRequest"] = betterproto.message_field(1)
    """All calculated channels to resolve."""


@dataclass(eq=False, repr=False)
class BatchResolveCalculatedChannelsResponse(betterproto.Message):
    """
    The response of a call to `CalculatedChannelService_BatchResolveCalculatedChannels`.
    """

    responses: List["ResolveCalculatedChannelResponse"] = betterproto.message_field(1)
    """All calculated channels that attempted resolution."""


class CalculatedChannelServiceStub(betterproto.ServiceStub):
    async def get_calculated_channel(
        self,
        get_calculated_channel_request: "GetCalculatedChannelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetCalculatedChannelResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/GetCalculatedChannel",
            get_calculated_channel_request,
            GetCalculatedChannelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_calculated_channel(
        self,
        create_calculated_channel_request: "CreateCalculatedChannelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateCalculatedChannelResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/CreateCalculatedChannel",
            create_calculated_channel_request,
            CreateCalculatedChannelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_calculated_channels(
        self,
        list_calculated_channels_request: "ListCalculatedChannelsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListCalculatedChannelsResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/ListCalculatedChannels",
            list_calculated_channels_request,
            ListCalculatedChannelsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_calculated_channel(
        self,
        update_calculated_channel_request: "UpdateCalculatedChannelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateCalculatedChannelResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/UpdateCalculatedChannel",
            update_calculated_channel_request,
            UpdateCalculatedChannelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_calculated_channel_versions(
        self,
        list_calculated_channel_versions_request: "ListCalculatedChannelVersionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListCalculatedChannelVersionsResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/ListCalculatedChannelVersions",
            list_calculated_channel_versions_request,
            ListCalculatedChannelVersionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def resolve_calculated_channel(
        self,
        resolve_calculated_channel_request: "ResolveCalculatedChannelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResolveCalculatedChannelResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/ResolveCalculatedChannel",
            resolve_calculated_channel_request,
            ResolveCalculatedChannelResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_resolve_calculated_channels(
        self,
        batch_resolve_calculated_channels_request: "BatchResolveCalculatedChannelsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchResolveCalculatedChannelsResponse":
        return await self._unary_unary(
            "/sift.calculated_channels.v2.CalculatedChannelService/BatchResolveCalculatedChannels",
            batch_resolve_calculated_channels_request,
            BatchResolveCalculatedChannelsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class CalculatedChannelServiceBase(ServiceBase):

    async def get_calculated_channel(
        self, get_calculated_channel_request: "GetCalculatedChannelRequest"
    ) -> "GetCalculatedChannelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_calculated_channel(
        self, create_calculated_channel_request: "CreateCalculatedChannelRequest"
    ) -> "CreateCalculatedChannelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_calculated_channels(
        self, list_calculated_channels_request: "ListCalculatedChannelsRequest"
    ) -> "ListCalculatedChannelsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_calculated_channel(
        self, update_calculated_channel_request: "UpdateCalculatedChannelRequest"
    ) -> "UpdateCalculatedChannelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_calculated_channel_versions(
        self,
        list_calculated_channel_versions_request: "ListCalculatedChannelVersionsRequest",
    ) -> "ListCalculatedChannelVersionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resolve_calculated_channel(
        self, resolve_calculated_channel_request: "ResolveCalculatedChannelRequest"
    ) -> "ResolveCalculatedChannelResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_resolve_calculated_channels(
        self,
        batch_resolve_calculated_channels_request: "BatchResolveCalculatedChannelsRequest",
    ) -> "BatchResolveCalculatedChannelsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_calculated_channel(
        self,
        stream: "grpclib.server.Stream[GetCalculatedChannelRequest, GetCalculatedChannelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_calculated_channel(request)
        await stream.send_message(response)

    async def __rpc_create_calculated_channel(
        self,
        stream: "grpclib.server.Stream[CreateCalculatedChannelRequest, CreateCalculatedChannelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_calculated_channel(request)
        await stream.send_message(response)

    async def __rpc_list_calculated_channels(
        self,
        stream: "grpclib.server.Stream[ListCalculatedChannelsRequest, ListCalculatedChannelsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_calculated_channels(request)
        await stream.send_message(response)

    async def __rpc_update_calculated_channel(
        self,
        stream: "grpclib.server.Stream[UpdateCalculatedChannelRequest, UpdateCalculatedChannelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_calculated_channel(request)
        await stream.send_message(response)

    async def __rpc_list_calculated_channel_versions(
        self,
        stream: "grpclib.server.Stream[ListCalculatedChannelVersionsRequest, ListCalculatedChannelVersionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_calculated_channel_versions(request)
        await stream.send_message(response)

    async def __rpc_resolve_calculated_channel(
        self,
        stream: "grpclib.server.Stream[ResolveCalculatedChannelRequest, ResolveCalculatedChannelResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.resolve_calculated_channel(request)
        await stream.send_message(response)

    async def __rpc_batch_resolve_calculated_channels(
        self,
        stream: "grpclib.server.Stream[BatchResolveCalculatedChannelsRequest, BatchResolveCalculatedChannelsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_resolve_calculated_channels(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.calculated_channels.v2.CalculatedChannelService/GetCalculatedChannel": grpclib.const.Handler(
                self.__rpc_get_calculated_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCalculatedChannelRequest,
                GetCalculatedChannelResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/CreateCalculatedChannel": grpclib.const.Handler(
                self.__rpc_create_calculated_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateCalculatedChannelRequest,
                CreateCalculatedChannelResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/ListCalculatedChannels": grpclib.const.Handler(
                self.__rpc_list_calculated_channels,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListCalculatedChannelsRequest,
                ListCalculatedChannelsResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/UpdateCalculatedChannel": grpclib.const.Handler(
                self.__rpc_update_calculated_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateCalculatedChannelRequest,
                UpdateCalculatedChannelResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/ListCalculatedChannelVersions": grpclib.const.Handler(
                self.__rpc_list_calculated_channel_versions,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListCalculatedChannelVersionsRequest,
                ListCalculatedChannelVersionsResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/ResolveCalculatedChannel": grpclib.const.Handler(
                self.__rpc_resolve_calculated_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResolveCalculatedChannelRequest,
                ResolveCalculatedChannelResponse,
            ),
            "/sift.calculated_channels.v2.CalculatedChannelService/BatchResolveCalculatedChannels": grpclib.const.Handler(
                self.__rpc_batch_resolve_calculated_channels,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchResolveCalculatedChannelsRequest,
                BatchResolveCalculatedChannelsResponse,
            ),
        }
