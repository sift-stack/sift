# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/rule_evaluation/v1/rule_evaluation.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common.type import v1 as __common_type_v1__
from ...rules import v1 as __rules_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class EvaluateRulesRequest(betterproto.Message):
    run: "__common_type_v1__.ResourceIdentifier" = betterproto.message_field(
        1, group="time"
    )
    assets: "AssetsTimeRange" = betterproto.message_field(2, group="time")
    rules: "EvaluateRulesFromCurrentRuleVersions" = betterproto.message_field(
        3, group="mode"
    )
    rule_versions: "EvaluateRulesFromRuleVersions" = betterproto.message_field(
        4, group="mode"
    )
    report_template: "EvaluateRulesFromReportTemplate" = betterproto.message_field(
        5, group="mode"
    )
    annotation_options: "EvaluateRulesAnnotationOptions" = betterproto.message_field(6)
    organization_id: str = betterproto.string_field(7)
    """Only required if your user belongs to multiple organizations"""

    report_name: Optional[str] = betterproto.string_field(8, optional=True)
    """
    If this request creates a report, this field will be used as the report name.
    """


@dataclass(eq=False, repr=False)
class AssetsTimeRange(betterproto.Message):
    assets: "__common_type_v1__.NamedResources" = betterproto.message_field(1)
    start_time: datetime = betterproto.message_field(2)
    end_time: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class EvaluateRulesFromCurrentRuleVersions(betterproto.Message):
    rules: "__common_type_v1__.ResourceIdentifiers" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EvaluateRulesFromReportTemplate(betterproto.Message):
    report_template: "__common_type_v1__.ResourceIdentifier" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class EvaluateRulesFromRuleVersions(betterproto.Message):
    rule_version_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EvaluateRulesAnnotationOptions(betterproto.Message):
    tags: "__common_type_v1__.NamedResources" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EvaluateRulesResponse(betterproto.Message):
    created_annotation_count: int = betterproto.int32_field(1)
    report_id: Optional[str] = betterproto.string_field(2, optional=True)
    """A report will be generated if rules were evaluated against a run."""

    job_id: Optional[str] = betterproto.string_field(3, optional=True)
    """
    This will be set if the job has an extended run time and is being processed asynchronously.
    """


@dataclass(eq=False, repr=False)
class EvaluateRulesPreviewRequest(betterproto.Message):
    run: "__common_type_v1__.ResourceIdentifier" = betterproto.message_field(
        1, group="time"
    )
    rules: "EvaluateRulesFromCurrentRuleVersions" = betterproto.message_field(
        3, group="mode"
    )
    rule_versions: "EvaluateRulesFromRuleVersions" = betterproto.message_field(
        4, group="mode"
    )
    report_template: "EvaluateRulesFromReportTemplate" = betterproto.message_field(
        5, group="mode"
    )
    rule_configs: "EvaluateRulesFromRuleConfigs" = betterproto.message_field(
        6, group="mode"
    )
    organization_id: str = betterproto.string_field(7)
    """Only required if your user belongs to multiple organizations"""


@dataclass(eq=False, repr=False)
class EvaluateRulesFromRuleConfigs(betterproto.Message):
    configs: List["__rules_v1__.UpdateRuleRequest"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EvaluateRulesPreviewResponse(betterproto.Message):
    created_annotation_count: int = betterproto.int32_field(1)
    dry_run_annotations: List["__rules_v1__.DryRunAnnotation"] = (
        betterproto.message_field(2)
    )


class RuleEvaluationServiceStub(betterproto.ServiceStub):
    async def evaluate_rules(
        self,
        evaluate_rules_request: "EvaluateRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EvaluateRulesResponse":
        return await self._unary_unary(
            "/sift.rule_evaluation.v1.RuleEvaluationService/EvaluateRules",
            evaluate_rules_request,
            EvaluateRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def evaluate_rules_preview(
        self,
        evaluate_rules_preview_request: "EvaluateRulesPreviewRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EvaluateRulesPreviewResponse":
        return await self._unary_unary(
            "/sift.rule_evaluation.v1.RuleEvaluationService/EvaluateRulesPreview",
            evaluate_rules_preview_request,
            EvaluateRulesPreviewResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RuleEvaluationServiceBase(ServiceBase):

    async def evaluate_rules(
        self, evaluate_rules_request: "EvaluateRulesRequest"
    ) -> "EvaluateRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_rules_preview(
        self, evaluate_rules_preview_request: "EvaluateRulesPreviewRequest"
    ) -> "EvaluateRulesPreviewResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_evaluate_rules(
        self,
        stream: "grpclib.server.Stream[EvaluateRulesRequest, EvaluateRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.evaluate_rules(request)
        await stream.send_message(response)

    async def __rpc_evaluate_rules_preview(
        self,
        stream: "grpclib.server.Stream[EvaluateRulesPreviewRequest, EvaluateRulesPreviewResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.evaluate_rules_preview(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.rule_evaluation.v1.RuleEvaluationService/EvaluateRules": grpclib.const.Handler(
                self.__rpc_evaluate_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluateRulesRequest,
                EvaluateRulesResponse,
            ),
            "/sift.rule_evaluation.v1.RuleEvaluationService/EvaluateRulesPreview": grpclib.const.Handler(
                self.__rpc_evaluate_rules_preview,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluateRulesPreviewRequest,
                EvaluateRulesPreviewResponse,
            ),
        }
