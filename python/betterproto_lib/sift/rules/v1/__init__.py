# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sift/rules/v1/rules.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...annotations import v1 as __annotations_v1__
from ...common.type import v1 as __common_type_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class SearchOrder(betterproto.Enum):
    UNSPECIFIED = 0
    ASC = 1
    DESC = 2


class ActionKind(betterproto.Enum):
    UNSPECIFIED = 0
    NOTIFICATION = 1
    ANNOTATION = 2


class ConditionComparator(betterproto.Enum):
    UNSPECIFIED = 0
    LESS_THAN = 1
    LESS_THAN_OR_EQUAL = 2
    GREATER_THAN = 3
    GREATER_THAN_OR_EQUAL = 4
    EQUAL = 5
    NOT_EQUAL = 6


@dataclass(eq=False, repr=False)
class Rule(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    asset_id: str = betterproto.string_field(2)
    name: str = betterproto.string_field(3)
    description: str = betterproto.string_field(4)
    is_enabled: bool = betterproto.bool_field(6)
    created_date: datetime = betterproto.message_field(7)
    modified_date: datetime = betterproto.message_field(8)
    created_by_user_id: str = betterproto.string_field(9)
    modified_by_user_id: str = betterproto.string_field(10)
    organization_id: str = betterproto.string_field(11)
    conditions: List["RuleCondition"] = betterproto.message_field(12)
    rule_version: "RuleVersion" = betterproto.message_field(13)
    client_key: str = betterproto.string_field(14)
    """
    client_key is a client provided identifier for the rule. It is immutable after rule creation.
    """

    asset_configuration: "RuleAssetConfiguration" = betterproto.message_field(15)
    contextual_channels: "ContextualChannels" = betterproto.message_field(16)
    deleted_date: datetime = betterproto.message_field(17)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("asset_id"):
            warnings.warn("Rule.asset_id is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class RuleCondition(betterproto.Message):
    rule_condition_id: str = betterproto.string_field(1)
    rule_id: str = betterproto.string_field(2)
    expression: "RuleConditionExpression" = betterproto.message_field(3)
    created_date: datetime = betterproto.message_field(5)
    modified_date: datetime = betterproto.message_field(6)
    created_by_user_id: str = betterproto.string_field(7)
    modified_by_user_id: str = betterproto.string_field(8)
    actions: List["RuleAction"] = betterproto.message_field(9)
    rule_condition_version_id: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class RuleAction(betterproto.Message):
    rule_action_id: str = betterproto.string_field(1)
    rule_condition_id: str = betterproto.string_field(2)
    action_type: "ActionKind" = betterproto.enum_field(3)
    configuration: "RuleActionConfiguration" = betterproto.message_field(4)
    created_date: datetime = betterproto.message_field(5)
    modified_date: datetime = betterproto.message_field(6)
    created_by_user_id: str = betterproto.string_field(7)
    modified_by_user_id: str = betterproto.string_field(8)
    rule_action_version_id: str = betterproto.string_field(9)


@dataclass(eq=False, repr=False)
class RuleAssetConfiguration(betterproto.Message):
    asset_ids: List[str] = betterproto.string_field(1)
    tag_ids: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ContextualChannels(betterproto.Message):
    channels: List["ChannelReference"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class AssetExpressionValidationResult(betterproto.Message):
    asset_id: str = betterproto.string_field(1)
    asset_name: str = betterproto.string_field(2)
    asset_tag_id: str = betterproto.string_field(3)
    """
    asset_tag_id is the tag_id that caused this asset to be included in the rule
    """

    error: Optional[str] = betterproto.string_field(4, optional=True)


@dataclass(eq=False, repr=False)
class SearchRulesRequest(betterproto.Message):
    limit: Optional[int] = betterproto.uint32_field(1, optional=True)
    """Max number of rules to return (returns all if omitted)."""

    offset: int = betterproto.uint32_field(2)
    """Only applies if limit provided."""

    order: Optional["SearchOrder"] = betterproto.enum_field(3, optional=True)
    """Order to sort results by (defaults to ascending)."""

    name_matches: str = betterproto.string_field(4)
    case_sensitive: bool = betterproto.bool_field(5)
    regexp: bool = betterproto.bool_field(6)
    order_by: Optional[str] = betterproto.string_field(7, optional=True)
    rule_ids: List[str] = betterproto.string_field(8)
    """If provided, only returns rules with the given ids"""

    asset_ids: List[str] = betterproto.string_field(9)
    """If provided, only returns rules that apply to the given asset ids"""

    include_deleted: bool = betterproto.bool_field(10)
    asset_tags: "__common_type_v1__.NamedResources" = betterproto.message_field(11)
    """If provided, returns rules with assets that have the given tags"""


@dataclass(eq=False, repr=False)
class SearchRulesResponse(betterproto.Message):
    count: int = betterproto.uint32_field(1)
    rules: List["Rule"] = betterproto.message_field(2)
    """
    Conditions are not included in the search response. The latest version of the rule is returned.
    """


@dataclass(eq=False, repr=False)
class GetRuleRequest(betterproto.Message):
    """
    GetRuleRequest is used to retrieve a rule by rule_id or client_key. If both are provided, only rule_id will be used.
    """

    rule_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetRuleResponse(betterproto.Message):
    rule: "Rule" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BatchGetRulesRequest(betterproto.Message):
    """
    BatchGetRulesRequest is used to retrieve rules by rule_ids or client_keys. If both are provided, both will be used to retrieve rules.
    """

    rule_ids: List[str] = betterproto.string_field(1)
    client_keys: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BatchGetRulesResponse(betterproto.Message):
    rules: List["Rule"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateRuleRequest(betterproto.Message):
    update: "UpdateRuleRequest" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateRuleResponse(betterproto.Message):
    rule_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class UpdateRuleRequest(betterproto.Message):
    """
    UpdateRuleRequest is used to create or update a rule. If the rule_id or client_key is provided, the rule will be updated. If not, a new rule will be created.
    """

    rule_id: Optional[str] = betterproto.string_field(1, optional=True)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    asset_id: str = betterproto.string_field(4)
    """Deprecated - use asset_configuration instead."""

    is_enabled: bool = betterproto.bool_field(5)
    conditions: List["UpdateConditionRequest"] = betterproto.message_field(6)
    organization_id: str = betterproto.string_field(7)
    version_notes: str = betterproto.string_field(8)
    client_key: Optional[str] = betterproto.string_field(9, optional=True)
    """
    client_key is a client provided identifier for the rule. It is immutable after being set
    """

    asset_configuration: "RuleAssetConfiguration" = betterproto.message_field(10)
    contextual_channels: "ContextualChannels" = betterproto.message_field(11)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("asset_id"):
            warnings.warn(
                "UpdateRuleRequest.asset_id is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class UpdateConditionRequest(betterproto.Message):
    rule_condition_id: Optional[str] = betterproto.string_field(1, optional=True)
    expression: "RuleConditionExpression" = betterproto.message_field(3)
    actions: List["UpdateActionRequest"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class UpdateActionRequest(betterproto.Message):
    rule_action_id: Optional[str] = betterproto.string_field(1, optional=True)
    action_type: "ActionKind" = betterproto.enum_field(2)
    configuration: "RuleActionConfiguration" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateRuleResponse(betterproto.Message):
    rule_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ValidationResult(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)
    asset_expression_validation_results: List["AssetExpressionValidationResult"] = (
        betterproto.message_field(3)
    )
    """
    If the expression is invalid for an asset, one or more AssetExpressionValidationResult will be returned. This may block
     saving if the override_expression_validation flag is not set.
    """

    error: Optional[str] = betterproto.string_field(4, optional=True)
    """
    If the rule is invalid and unable to be saved, this will contain the error message. Expression errors will be returned in
     the asset_expression_validation_results.
    """


@dataclass(eq=False, repr=False)
class BatchUpdateRulesRequest(betterproto.Message):
    rules: List["UpdateRuleRequest"] = betterproto.message_field(1)
    """rules are limited 1000 rules at a time"""

    validate_only: bool = betterproto.bool_field(2)
    """
    If validate_only is true, the request will only validate the request and not save the rules.
    """

    override_expression_validation: bool = betterproto.bool_field(3)
    """
    If override_expression_validation is true, the request will save the rules even if the expressions are invalid. This
     can be useful for multi-asset rules where an invalid expression for one asset should not prevent the rule from being saved.
    """


@dataclass(eq=False, repr=False)
class BatchUpdateRulesResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    rules_created_count: int = betterproto.int32_field(2)
    """
    The total number of rules created in the request. If validate_only is true, this will indicate how many rules would have been created.
    """

    rules_updated_count: int = betterproto.int32_field(3)
    """
    The total number of rules updated in the request. If validate_only is true, this will indicate how many rules would have been updated.
    """

    validate_only: bool = betterproto.bool_field(4)
    """
    This will be true if the request only validated the request and did not save the rules.
    """

    validation_results: List["ValidationResult"] = betterproto.message_field(5)
    """One ValidationResult per rule in the request will be returned"""


@dataclass(eq=False, repr=False)
class DeleteRuleRequest(betterproto.Message):
    """
    DeleteRuleRequest is used to delete a rule by rule_id or client_key. If both are provided, only rule_id will be used.
    """

    rule_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeleteRuleResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BatchDeleteRulesRequest(betterproto.Message):
    """
    BatchDeleteRulesRequest is used to delete a rule by rule_id or client_key. For each rule if both are provided, only rule_id will be used.
    """

    rule_ids: List[str] = betterproto.string_field(1)
    client_keys: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BatchDeleteRulesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UndeleteRuleRequest(betterproto.Message):
    """
    UndeleteRuleRequest is used to undelete a rule by rule_id or client_key. If both are provided, only rule_id will be used.
    """

    rule_id: str = betterproto.string_field(1)
    client_key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class UndeleteRuleResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class BatchUndeleteRulesRequest(betterproto.Message):
    """
    BatchUndeleteRulesRequest is used to delete a rule by rule_id or client_key. For each rule if both are provided, only rule_id will be used.
    """

    rule_ids: List[str] = betterproto.string_field(1)
    client_keys: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BatchUndeleteRulesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ViewHumanFriendlyRulesRequest(betterproto.Message):
    """Deprecated - use ViewJsonRulesRequest."""

    asset_id: str = betterproto.string_field(1)

    def __post_init__(self) -> None:
        warnings.warn("ViewHumanFriendlyRulesRequest is deprecated", DeprecationWarning)
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ViewHumanFriendlyRulesResponse(betterproto.Message):
    """Deprecated - use ViewJsonRulesResponse."""

    rules_json: str = betterproto.string_field(1)

    def __post_init__(self) -> None:
        warnings.warn(
            "ViewHumanFriendlyRulesResponse is deprecated", DeprecationWarning
        )
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateHumanFriendlyRulesRequest(betterproto.Message):
    """Deprecated - use UpdateJsonRulesRequest."""

    asset_id: str = betterproto.string_field(1)
    rules_json: str = betterproto.string_field(2)
    organization_id: str = betterproto.string_field(3)

    def __post_init__(self) -> None:
        warnings.warn(
            "UpdateHumanFriendlyRulesRequest is deprecated", DeprecationWarning
        )
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateHumanFriendlyRulesResponse(betterproto.Message):
    """Deprecated - use UpdateJsonRulesResponse."""

    success: bool = betterproto.bool_field(1)
    rules_count: int = betterproto.int32_field(2)
    messages: str = betterproto.string_field(3)

    def __post_init__(self) -> None:
        warnings.warn(
            "UpdateHumanFriendlyRulesResponse is deprecated", DeprecationWarning
        )
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ViewJsonRulesRequest(betterproto.Message):
    asset_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ViewJsonRulesResponse(betterproto.Message):
    rules_json: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class JsonRulesRequest(betterproto.Message):
    asset_id: str = betterproto.string_field(1)
    rules_json: str = betterproto.string_field(2)
    organization_id: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class JsonRulesResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    total_rules_count: int = betterproto.int32_field(2)
    rules_created_count: int = betterproto.int32_field(3)
    rules_updated_count: int = betterproto.int32_field(4)
    rules_deleted_count: int = betterproto.int32_field(5)
    error_messages: Optional[str] = betterproto.string_field(6, optional=True)


@dataclass(eq=False, repr=False)
class ValidateJsonRulesRequest(betterproto.Message):
    request: "JsonRulesRequest" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ValidateJsonRulesResponse(betterproto.Message):
    response: "JsonRulesResponse" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateJsonRulesRequest(betterproto.Message):
    request: "JsonRulesRequest" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateJsonRulesResponse(betterproto.Message):
    response: "JsonRulesResponse" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ListRulesRequest(betterproto.Message):
    page_size: int = betterproto.uint32_field(1)
    """
    The maximum number of Rules to return.
     The service may return fewer than this value.
     If unspecified, at most 50 Rules will be returned.
     The maximum value is 1000; values above 1000 will be coerced to 1000.
    """

    page_token: str = betterproto.string_field(2)
    """
    A page token, received from a previous `ListRules` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListRules` must match
     the call that provided the page token.
    """

    filter: str = betterproto.string_field(3)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `rule_id`, `client_key`, `name`, and `description`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
     Optional.
    """

    order_by: str = betterproto.string_field(4)
    """
    How to order the retrieved Rules. Formatted as a comma-separated string i.e. "FIELD_NAME[ desc],...".
     Available fields to order_by are `created_date` and `modified_date`.
     If left empty, items are ordered by `created_date` in ascending order (oldest-first).
    """


@dataclass(eq=False, repr=False)
class ListRulesResponse(betterproto.Message):
    rules: List["Rule"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ListRuleVersionsRequest(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    page_size: int = betterproto.uint32_field(2)
    """
    The maximum number of Rule Versions to return.
     The service may return fewer than this value.
     If unspecified, at most 50 Rule Versions will be returned.
     The maximum value is 1000; values above 1000 will be coerced to 1000.
    """

    page_token: str = betterproto.string_field(3)
    """
    A page token, received from a previous `ListRuleVersions` call.
     Provide this to retrieve the subsequent page.
     When paginating, all other parameters provided to `ListRuleVersions` must match
     the call that provided the page token.
    """

    filter: str = betterproto.string_field(4)
    """
    A [Common Expression Language (CEL)](https://github.com/google/cel-spec) filter string.
     Available fields to filter by are `rule_version_id`, `user_notes`,  and `change_message`.
     For further information about how to use CELs, please refer to [this guide](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions). Optional.
    """


@dataclass(eq=False, repr=False)
class RuleVersion(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    rule_version_id: str = betterproto.string_field(2)
    version: str = betterproto.string_field(3)
    created_date: datetime = betterproto.message_field(4)
    created_by_user_id: str = betterproto.string_field(5)
    version_notes: str = betterproto.string_field(6)
    generated_change_message: str = betterproto.string_field(7)
    deleted_date: datetime = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class ListRuleVersionsResponse(betterproto.Message):
    rule_versions: List["RuleVersion"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetRuleVersionRequest(betterproto.Message):
    rule_version_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetRuleVersionResponse(betterproto.Message):
    rule: "Rule" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BatchGetRuleVersionsRequest(betterproto.Message):
    rule_version_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class BatchGetRuleVersionsResponse(betterproto.Message):
    rules: List["Rule"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RuleConditionExpression(betterproto.Message):
    single_channel_comparison: "SingleChannelComparisonExpression" = (
        betterproto.message_field(1, group="expression")
    )
    calculated_channel: "CalculatedChannelConfig" = betterproto.message_field(
        2, group="expression"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("single_channel_comparison"):
            warnings.warn(
                "RuleConditionExpression.single_channel_comparison is deprecated",
                DeprecationWarning,
            )


@dataclass(eq=False, repr=False)
class SingleChannelComparisonExpression(betterproto.Message):
    """Deprecated - use CalculatedChannelConfig."""

    channel_component: str = betterproto.string_field(1)
    """
    Deprecated - use channel_name instead. If provided, channel_component will be joined with the name as `channel_component.channel_name`
    """

    channel_name: str = betterproto.string_field(2)
    comparator: "ConditionComparator" = betterproto.enum_field(3)
    double: float = betterproto.double_field(4, group="threshold")
    string: str = betterproto.string_field(5, group="threshold")
    last_value: "LastValueThreshold" = betterproto.message_field(6, group="threshold")


@dataclass(eq=False, repr=False)
class LastValueThreshold(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CalculatedChannelConfig(betterproto.Message):
    channel_references: Dict[str, "ChannelReference"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    expression: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ChannelReference(betterproto.Message):
    name: str = betterproto.string_field(1)
    component: str = betterproto.string_field(2)
    """
    Deprecated - use name instead. If provided, name will be joined with the component as `component.name`
    """


@dataclass(eq=False, repr=False)
class RuleActionConfiguration(betterproto.Message):
    notification: "NotificationActionConfiguration" = betterproto.message_field(
        1, group="configuration"
    )
    annotation: "AnnotationActionConfiguration" = betterproto.message_field(
        2, group="configuration"
    )


@dataclass(eq=False, repr=False)
class NotificationActionConfiguration(betterproto.Message):
    recipient_user_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class AnnotationActionConfiguration(betterproto.Message):
    tag_ids: List[str] = betterproto.string_field(1)
    annotation_type: "__annotations_v1__.AnnotationType" = betterproto.enum_field(2)
    assigned_to_user_id: Optional[str] = betterproto.string_field(3, optional=True)


@dataclass(eq=False, repr=False)
class EvaluateRulesRequest(betterproto.Message):
    """Deprecated - use RuleEvaluationService instead."""

    rule_ids: List[str] = betterproto.string_field(1)
    annotation_options: "EvaluatedAnnotationOptions" = betterproto.message_field(2)
    run_id: str = betterproto.string_field(3, group="time")
    time_range: "TimeRangeQuery" = betterproto.message_field(4, group="time")
    dry_run: bool = betterproto.bool_field(5)

    def __post_init__(self) -> None:
        warnings.warn("EvaluateRulesRequest is deprecated", DeprecationWarning)
        super().__post_init__()


@dataclass(eq=False, repr=False)
class EvaluatedAnnotationOptions(betterproto.Message):
    tag_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class TimeRangeQuery(betterproto.Message):
    start_time: datetime = betterproto.message_field(1)
    end_time: datetime = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EvaluateRulesResponse(betterproto.Message):
    """Deprecated - use RuleEvaluationService instead."""

    created_annotation_count: int = betterproto.int32_field(1)
    dry_run_annotations: List["DryRunAnnotation"] = betterproto.message_field(2)
    """
    If dry_run is true, this will be populated with the annotations that would be created
    """

    job_id: Optional[str] = betterproto.string_field(3, optional=True)
    """
    job_id and report_id will be set if the job has an extended run time and is being processed asynchronously.
    """

    report_id: Optional[str] = betterproto.string_field(4, optional=True)

    def __post_init__(self) -> None:
        warnings.warn("EvaluateRulesResponse is deprecated", DeprecationWarning)
        super().__post_init__()


@dataclass(eq=False, repr=False)
class DryRunAnnotation(betterproto.Message):
    condition_id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    start_time: datetime = betterproto.message_field(3)
    end_time: datetime = betterproto.message_field(4)
    condition_version_id: str = betterproto.string_field(5)


class RuleServiceStub(betterproto.ServiceStub):
    async def search_rules(
        self,
        search_rules_request: "SearchRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/SearchRules",
            search_rules_request,
            SearchRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_rule(
        self,
        get_rule_request: "GetRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetRuleResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/GetRule",
            get_rule_request,
            GetRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_get_rules(
        self,
        batch_get_rules_request: "BatchGetRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchGetRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/BatchGetRules",
            batch_get_rules_request,
            BatchGetRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_rule(
        self,
        create_rule_request: "CreateRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateRuleResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/CreateRule",
            create_rule_request,
            CreateRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_rule(
        self,
        update_rule_request: "UpdateRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateRuleResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/UpdateRule",
            update_rule_request,
            UpdateRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_update_rules(
        self,
        batch_update_rules_request: "BatchUpdateRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchUpdateRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/BatchUpdateRules",
            batch_update_rules_request,
            BatchUpdateRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_rule(
        self,
        delete_rule_request: "DeleteRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteRuleResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/DeleteRule",
            delete_rule_request,
            DeleteRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_delete_rules(
        self,
        batch_delete_rules_request: "BatchDeleteRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchDeleteRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/BatchDeleteRules",
            batch_delete_rules_request,
            BatchDeleteRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def undelete_rule(
        self,
        undelete_rule_request: "UndeleteRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UndeleteRuleResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/UndeleteRule",
            undelete_rule_request,
            UndeleteRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_undelete_rules(
        self,
        batch_undelete_rules_request: "BatchUndeleteRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchUndeleteRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/BatchUndeleteRules",
            batch_undelete_rules_request,
            BatchUndeleteRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def evaluate_rules(
        self,
        evaluate_rules_request: "EvaluateRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EvaluateRulesResponse":
        warnings.warn("RuleService.evaluate_rules is deprecated", DeprecationWarning)

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/EvaluateRules",
            evaluate_rules_request,
            EvaluateRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def view_human_friendly_rules(
        self,
        view_human_friendly_rules_request: "ViewHumanFriendlyRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ViewHumanFriendlyRulesResponse":
        warnings.warn(
            "RuleService.view_human_friendly_rules is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/ViewHumanFriendlyRules",
            view_human_friendly_rules_request,
            ViewHumanFriendlyRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def view_json_rules(
        self,
        view_json_rules_request: "ViewJsonRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ViewJsonRulesResponse":
        warnings.warn("RuleService.view_json_rules is deprecated", DeprecationWarning)

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/ViewJsonRules",
            view_json_rules_request,
            ViewJsonRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_human_friendly_rules(
        self,
        update_human_friendly_rules_request: "UpdateHumanFriendlyRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateHumanFriendlyRulesResponse":
        warnings.warn(
            "RuleService.update_human_friendly_rules is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/UpdateHumanFriendlyRules",
            update_human_friendly_rules_request,
            UpdateHumanFriendlyRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def validate_json_rules(
        self,
        validate_json_rules_request: "ValidateJsonRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ValidateJsonRulesResponse":
        warnings.warn(
            "RuleService.validate_json_rules is deprecated", DeprecationWarning
        )

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/ValidateJsonRules",
            validate_json_rules_request,
            ValidateJsonRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_json_rules(
        self,
        update_json_rules_request: "UpdateJsonRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateJsonRulesResponse":
        warnings.warn("RuleService.update_json_rules is deprecated", DeprecationWarning)

        return await self._unary_unary(
            "/sift.rules.v1.RuleService/UpdateJsonRules",
            update_json_rules_request,
            UpdateJsonRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_rules(
        self,
        list_rules_request: "ListRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListRulesResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/ListRules",
            list_rules_request,
            ListRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_rule_versions(
        self,
        list_rule_versions_request: "ListRuleVersionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListRuleVersionsResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/ListRuleVersions",
            list_rule_versions_request,
            ListRuleVersionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_rule_version(
        self,
        get_rule_version_request: "GetRuleVersionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetRuleVersionResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/GetRuleVersion",
            get_rule_version_request,
            GetRuleVersionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_get_rule_versions(
        self,
        batch_get_rule_versions_request: "BatchGetRuleVersionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BatchGetRuleVersionsResponse":
        return await self._unary_unary(
            "/sift.rules.v1.RuleService/BatchGetRuleVersions",
            batch_get_rule_versions_request,
            BatchGetRuleVersionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RuleServiceBase(ServiceBase):

    async def search_rules(
        self, search_rules_request: "SearchRulesRequest"
    ) -> "SearchRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_rule(self, get_rule_request: "GetRuleRequest") -> "GetRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_get_rules(
        self, batch_get_rules_request: "BatchGetRulesRequest"
    ) -> "BatchGetRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_rule(
        self, create_rule_request: "CreateRuleRequest"
    ) -> "CreateRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_rule(
        self, update_rule_request: "UpdateRuleRequest"
    ) -> "UpdateRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_update_rules(
        self, batch_update_rules_request: "BatchUpdateRulesRequest"
    ) -> "BatchUpdateRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_rule(
        self, delete_rule_request: "DeleteRuleRequest"
    ) -> "DeleteRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_delete_rules(
        self, batch_delete_rules_request: "BatchDeleteRulesRequest"
    ) -> "BatchDeleteRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def undelete_rule(
        self, undelete_rule_request: "UndeleteRuleRequest"
    ) -> "UndeleteRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_undelete_rules(
        self, batch_undelete_rules_request: "BatchUndeleteRulesRequest"
    ) -> "BatchUndeleteRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_rules(
        self, evaluate_rules_request: "EvaluateRulesRequest"
    ) -> "EvaluateRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def view_human_friendly_rules(
        self, view_human_friendly_rules_request: "ViewHumanFriendlyRulesRequest"
    ) -> "ViewHumanFriendlyRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def view_json_rules(
        self, view_json_rules_request: "ViewJsonRulesRequest"
    ) -> "ViewJsonRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_human_friendly_rules(
        self, update_human_friendly_rules_request: "UpdateHumanFriendlyRulesRequest"
    ) -> "UpdateHumanFriendlyRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def validate_json_rules(
        self, validate_json_rules_request: "ValidateJsonRulesRequest"
    ) -> "ValidateJsonRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_json_rules(
        self, update_json_rules_request: "UpdateJsonRulesRequest"
    ) -> "UpdateJsonRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_rules(
        self, list_rules_request: "ListRulesRequest"
    ) -> "ListRulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_rule_versions(
        self, list_rule_versions_request: "ListRuleVersionsRequest"
    ) -> "ListRuleVersionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_rule_version(
        self, get_rule_version_request: "GetRuleVersionRequest"
    ) -> "GetRuleVersionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_get_rule_versions(
        self, batch_get_rule_versions_request: "BatchGetRuleVersionsRequest"
    ) -> "BatchGetRuleVersionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_search_rules(
        self, stream: "grpclib.server.Stream[SearchRulesRequest, SearchRulesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_rules(request)
        await stream.send_message(response)

    async def __rpc_get_rule(
        self, stream: "grpclib.server.Stream[GetRuleRequest, GetRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_rule(request)
        await stream.send_message(response)

    async def __rpc_batch_get_rules(
        self,
        stream: "grpclib.server.Stream[BatchGetRulesRequest, BatchGetRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_get_rules(request)
        await stream.send_message(response)

    async def __rpc_create_rule(
        self, stream: "grpclib.server.Stream[CreateRuleRequest, CreateRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_rule(request)
        await stream.send_message(response)

    async def __rpc_update_rule(
        self, stream: "grpclib.server.Stream[UpdateRuleRequest, UpdateRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_rule(request)
        await stream.send_message(response)

    async def __rpc_batch_update_rules(
        self,
        stream: "grpclib.server.Stream[BatchUpdateRulesRequest, BatchUpdateRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_update_rules(request)
        await stream.send_message(response)

    async def __rpc_delete_rule(
        self, stream: "grpclib.server.Stream[DeleteRuleRequest, DeleteRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_rule(request)
        await stream.send_message(response)

    async def __rpc_batch_delete_rules(
        self,
        stream: "grpclib.server.Stream[BatchDeleteRulesRequest, BatchDeleteRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_delete_rules(request)
        await stream.send_message(response)

    async def __rpc_undelete_rule(
        self, stream: "grpclib.server.Stream[UndeleteRuleRequest, UndeleteRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.undelete_rule(request)
        await stream.send_message(response)

    async def __rpc_batch_undelete_rules(
        self,
        stream: "grpclib.server.Stream[BatchUndeleteRulesRequest, BatchUndeleteRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_undelete_rules(request)
        await stream.send_message(response)

    async def __rpc_evaluate_rules(
        self,
        stream: "grpclib.server.Stream[EvaluateRulesRequest, EvaluateRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.evaluate_rules(request)
        await stream.send_message(response)

    async def __rpc_view_human_friendly_rules(
        self,
        stream: "grpclib.server.Stream[ViewHumanFriendlyRulesRequest, ViewHumanFriendlyRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.view_human_friendly_rules(request)
        await stream.send_message(response)

    async def __rpc_view_json_rules(
        self,
        stream: "grpclib.server.Stream[ViewJsonRulesRequest, ViewJsonRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.view_json_rules(request)
        await stream.send_message(response)

    async def __rpc_update_human_friendly_rules(
        self,
        stream: "grpclib.server.Stream[UpdateHumanFriendlyRulesRequest, UpdateHumanFriendlyRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_human_friendly_rules(request)
        await stream.send_message(response)

    async def __rpc_validate_json_rules(
        self,
        stream: "grpclib.server.Stream[ValidateJsonRulesRequest, ValidateJsonRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.validate_json_rules(request)
        await stream.send_message(response)

    async def __rpc_update_json_rules(
        self,
        stream: "grpclib.server.Stream[UpdateJsonRulesRequest, UpdateJsonRulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_json_rules(request)
        await stream.send_message(response)

    async def __rpc_list_rules(
        self, stream: "grpclib.server.Stream[ListRulesRequest, ListRulesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_rules(request)
        await stream.send_message(response)

    async def __rpc_list_rule_versions(
        self,
        stream: "grpclib.server.Stream[ListRuleVersionsRequest, ListRuleVersionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_rule_versions(request)
        await stream.send_message(response)

    async def __rpc_get_rule_version(
        self,
        stream: "grpclib.server.Stream[GetRuleVersionRequest, GetRuleVersionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_rule_version(request)
        await stream.send_message(response)

    async def __rpc_batch_get_rule_versions(
        self,
        stream: "grpclib.server.Stream[BatchGetRuleVersionsRequest, BatchGetRuleVersionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.batch_get_rule_versions(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/sift.rules.v1.RuleService/SearchRules": grpclib.const.Handler(
                self.__rpc_search_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchRulesRequest,
                SearchRulesResponse,
            ),
            "/sift.rules.v1.RuleService/GetRule": grpclib.const.Handler(
                self.__rpc_get_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRuleRequest,
                GetRuleResponse,
            ),
            "/sift.rules.v1.RuleService/BatchGetRules": grpclib.const.Handler(
                self.__rpc_batch_get_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchGetRulesRequest,
                BatchGetRulesResponse,
            ),
            "/sift.rules.v1.RuleService/CreateRule": grpclib.const.Handler(
                self.__rpc_create_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateRuleRequest,
                CreateRuleResponse,
            ),
            "/sift.rules.v1.RuleService/UpdateRule": grpclib.const.Handler(
                self.__rpc_update_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRuleRequest,
                UpdateRuleResponse,
            ),
            "/sift.rules.v1.RuleService/BatchUpdateRules": grpclib.const.Handler(
                self.__rpc_batch_update_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchUpdateRulesRequest,
                BatchUpdateRulesResponse,
            ),
            "/sift.rules.v1.RuleService/DeleteRule": grpclib.const.Handler(
                self.__rpc_delete_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRuleRequest,
                DeleteRuleResponse,
            ),
            "/sift.rules.v1.RuleService/BatchDeleteRules": grpclib.const.Handler(
                self.__rpc_batch_delete_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchDeleteRulesRequest,
                BatchDeleteRulesResponse,
            ),
            "/sift.rules.v1.RuleService/UndeleteRule": grpclib.const.Handler(
                self.__rpc_undelete_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                UndeleteRuleRequest,
                UndeleteRuleResponse,
            ),
            "/sift.rules.v1.RuleService/BatchUndeleteRules": grpclib.const.Handler(
                self.__rpc_batch_undelete_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchUndeleteRulesRequest,
                BatchUndeleteRulesResponse,
            ),
            "/sift.rules.v1.RuleService/EvaluateRules": grpclib.const.Handler(
                self.__rpc_evaluate_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluateRulesRequest,
                EvaluateRulesResponse,
            ),
            "/sift.rules.v1.RuleService/ViewHumanFriendlyRules": grpclib.const.Handler(
                self.__rpc_view_human_friendly_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                ViewHumanFriendlyRulesRequest,
                ViewHumanFriendlyRulesResponse,
            ),
            "/sift.rules.v1.RuleService/ViewJsonRules": grpclib.const.Handler(
                self.__rpc_view_json_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                ViewJsonRulesRequest,
                ViewJsonRulesResponse,
            ),
            "/sift.rules.v1.RuleService/UpdateHumanFriendlyRules": grpclib.const.Handler(
                self.__rpc_update_human_friendly_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateHumanFriendlyRulesRequest,
                UpdateHumanFriendlyRulesResponse,
            ),
            "/sift.rules.v1.RuleService/ValidateJsonRules": grpclib.const.Handler(
                self.__rpc_validate_json_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                ValidateJsonRulesRequest,
                ValidateJsonRulesResponse,
            ),
            "/sift.rules.v1.RuleService/UpdateJsonRules": grpclib.const.Handler(
                self.__rpc_update_json_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateJsonRulesRequest,
                UpdateJsonRulesResponse,
            ),
            "/sift.rules.v1.RuleService/ListRules": grpclib.const.Handler(
                self.__rpc_list_rules,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListRulesRequest,
                ListRulesResponse,
            ),
            "/sift.rules.v1.RuleService/ListRuleVersions": grpclib.const.Handler(
                self.__rpc_list_rule_versions,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListRuleVersionsRequest,
                ListRuleVersionsResponse,
            ),
            "/sift.rules.v1.RuleService/GetRuleVersion": grpclib.const.Handler(
                self.__rpc_get_rule_version,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetRuleVersionRequest,
                GetRuleVersionResponse,
            ),
            "/sift.rules.v1.RuleService/BatchGetRuleVersions": grpclib.const.Handler(
                self.__rpc_batch_get_rule_versions,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchGetRuleVersionsRequest,
                BatchGetRuleVersionsResponse,
            ),
        }
