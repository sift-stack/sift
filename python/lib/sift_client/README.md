# Sift Client Library

This library provides a high-level Python client for interacting with Sift APIs. It offers both synchronous and
asynchronous interfaces, strong type checking, and a Pythonic API design.

## Overview

The library is organized into several main components:

1. **Client**: The main entry point that provides access to all Sift resources.
2. **Resources**: High-level APIs for interacting with Sift resources (Assets, Runs, etc.).
3. **Types**: Pydantic models for all domain objects with proper type checking.
4. **Transport**: Low-level clients for making REST and gRPC API calls to Sift services.

## For Developers

This section explains the architecture and design of the Sift Client library for developers who want to contribute or
understand the internals.

### Client and Resource Structure

The Sift Client library is structured in a layered architecture:

1. **Transport Layer** (`transport/`):
    - Handles low-level communication with Sift services
    - Implements both gRPC and REST transport options
    - Manages connection pooling, authentication, and retries

2. **Low-Level Wrappers** (`_internal/low_level_wrappers/`):
    - Pure async implementations that wrap gRPC stubs
    - Direct mapping to gRPC services
    - Handles serialization/deserialization between protocol buffers and Python objects

3. **Type System** (`types/`):
    - Defines Pydantic models for all domain objects
    - Provides conversion between protocol buffers and Python objects
    - Implements update models for partial updates with field masks

4. **High-Level APIs** (`resources/`):
    - Both async and sync versions
    - User-friendly interfaces with proper error handling
    - Pythonic methods that abstract away the complexity of the underlying gRPC calls

5. **Client** (`client.py`):
    - Main entry point for users
    - Provides access to all resource APIs
    - Manages configuration and authentication

### High-Level API Implementation and Generation

#### Async API Implementation

High-level APIs are implemented as async classes first:

1. Each resource type (Assets, Runs, etc.) has its own API class (e.g., `AssetsAPIAsync`)
2. These classes inherit from `ResourceBase` which provides common functionality
3. They use low-level clients to make the actual gRPC calls
4. They handle parameter validation, type conversion, and error handling
5. They return Pydantic models instead of raw protocol buffer objects

#### Sync API Generation

Synchronous versions of the APIs are automatically generated from the async versions:

1. The `generate_sync_api` function in `_internal/sync_wrapper.py` creates sync versions of async classes
2. It wraps each async method with a sync method that runs the async method in a dedicated event loop
3. It preserves method signatures, docstrings, and type hints
4. The generated sync classes are registered for later use in type stub generation

#### Type Stub Generation

Type stubs (.pyi files) are automatically generated for the sync APIs:

1. The `gen_pyi.py` script generates .pyi files for the sync APIs
2. It uses the registration list to find classes generated by `generate_sync_api`
3. It extracts method signatures, docstrings, and type hints from the sync classes
4. It generates type stubs that provide proper type checking for the sync APIs

This process ensures that both the async and sync APIs have proper type checking support.

### Sift Type System and Update Models

#### Base Type System

The type system is built on Pydantic models:

1. `BaseType` is the base class for all domain objects
2. It provides conversion between protocol buffers and Python objects
3. It attaches the client to the object for convenient access to mutations and related objects
4. It's immutable (frozen) to prevent accidental modification

#### Update Models

Update models are used for partial updates with field masks:

1. `ModelUpdate` is the base class for all update models
2. It provides conversion to protocol buffers with field masks
3. It only includes explicitly set fields in the update
4. It's mutable to allow building updates incrementally

#### Specific Types

Specific types inherit from `BaseType` and implement domain-specific logic:

1. Each domain object (Asset, Run, etc.) has its own type class
2. These classes implement conversion from protocol buffers
3. They define properties and methods specific to the domain object
4. They may have convenience methods that use the attached client

## Installation

```bash
pip install sift-client
```

For OpenSSL support:

```bash
pip install sift-client[openssl]
```

## Usage

### Wrapper Pattern

The wrapper pattern provides a common interface for different types of API clients (REST, gRPC, etc.) and handles common
concerns like configuration, error handling, and retries.

```python
from sift_client.transport.rest_transport import RestClient
from sift_client.transport.grpc_transport import GrpcClient
from sift_client.wrapper.utils import ClientError, retry

# See the REST and gRPC client implementations for examples of how to use the wrapper pattern.
```

### REST Service

The REST service provides a client for making REST API calls to Sift services.

```python
from sift_client.rest.client import RestClient, RestConfig

# Create a REST client configuration
config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
    timeout=30,
    use_ssl=True,
    max_retries=3,
    retry_backoff_factor=1.0,
    retry_status_forcelist=[500, 502, 503, 504],
    headers={"User-Agent": "SiftClient/1.0"},
)

# Create a REST client
client = RestClient(config)

# Make a GET request
response = client.get("/v1/users")

# Make a POST request
response = client.post(
    "/v1/users",
    json_data={"name": "John Doe", "email": "john.doe@example.com"},
)

# Make a PUT request
response = client.put(
    "/v1/users/123",
    json_data={"name": "Jane Doe"},
)

# Make a DELETE request
response = client.delete("/v1/users/123")

# Close the client when done
client.close()

# Or use the client as a context manager
with RestClient(config) as client:
    response = client.get("/v1/users")
```

### gRPC Service

The gRPC service provides a client for making gRPC API calls to Sift services.

```python
from sift_client.grpc.client import GrpcClient, GrpcConfig
from sift.ping.v1.ping_pb2 import PingRequest
from sift.ping.v1.ping_pb2_grpc import PingServiceStub

# Create a gRPC client configuration
config = GrpcConfig(
    uri="api.sift.com",
    api_key="your-api-key",
    use_ssl=True,
    max_retries=3,
    retry_delay=1.0,
    retry_backoff_factor=2.0,
    timeout=30,
)

# Create a gRPC client
client = GrpcClient(config)

# Get a stub for the service
ping_stub = client.get_stub(PingServiceStub)

# Create a request
request = PingRequest(message="Hello, world!")

# Execute the request
response = client.execute(ping_stub.Ping, request)

# Close the client when done
client.close()

# Or use the client as a context manager
with GrpcClient(config) as client:
    ping_stub = client.get_stub(PingServiceStub)
    request = PingRequest(message="Hello, world!")
    response = client.execute(ping_stub.Ping, request)
```

## Error Handling

The library provides a set of exception classes for handling errors:

- `ClientError`: Base exception for client errors.
- `RequestError`: Exception raised when a request fails.
- `AuthenticationError`: Exception raised when authentication fails.
- `RateLimitError`: Exception raised when rate limits are exceeded.
- `ServerError`: Exception raised when the server returns an error.
- `TimeoutError`: Exception raised when a request times out.

Example of error handling:

```python
from sift_client.wrapper.utils import ClientError, AuthenticationError, ServerError
from sift_client.rest.client import RestClient, RestConfig

# Create a REST client configuration
config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
)

# Create a REST client
client = RestClient(config)

try:
    response = client.get("/v1/users")
except AuthenticationError as e:
    print(f"Authentication failed: {e.message}")
except ServerError as e:
    print(f"Server error: {e.message}")
except ClientError as e:
    print(f"Request failed: {e.message}")
```

## Retry Logic

The library provides retry logic for handling transient errors:

```python
from sift_client.wrapper.utils import retry
from sift_client.rest.client import RestClient, RestConfig

# Create a REST client configuration
config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
)

# Create a REST client
client = RestClient(config)


@retry(max_retries=3, retry_delay=1.0, backoff_factor=2.0)
def make_request():
    # Make a request that might fail
    return client.get("/v1/users")
```

## Advanced Usage

### Custom Headers

```python
from sift_client.rest.client import RestClient, RestConfig
from sift_client.grpc.client import GrpcClient, GrpcConfig
from sift.ping.v1.ping_pb2 import PingRequest
from sift.ping.v1.ping_pb2_grpc import PingServiceStub

# REST client example
rest_config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
)
rest_client = RestClient(rest_config)
rest_response = rest_client.get(
    "/v1/users",
    headers={"X-Custom-Header": "value"},
)

# gRPC client example
grpc_config = GrpcConfig(
    uri="api.sift.com",
    api_key="your-api-key",
)
grpc_client = GrpcClient(grpc_config)
ping_stub = grpc_client.get_stub(PingServiceStub)
ping_request = PingRequest(message="Hello, world!")
grpc_response = grpc_client.execute(
    ping_stub.Ping,
    ping_request,
    metadata=[("x-custom-header", "value")],
)
```

### Timeout

```python
from sift_client.rest.client import RestClient, RestConfig
from sift_client.grpc.client import GrpcClient, GrpcConfig
from sift.ping.v1.ping_pb2 import PingRequest
from sift.ping.v1.ping_pb2_grpc import PingServiceStub

# REST client example
rest_config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
)
rest_client = RestClient(rest_config)
rest_response = rest_client.get(
    "/v1/users",
    timeout=60,  # 60 seconds
)

# gRPC client example
grpc_config = GrpcConfig(
    uri="api.sift.com",
    api_key="your-api-key",
)
grpc_client = GrpcClient(grpc_config)
ping_stub = grpc_client.get_stub(PingServiceStub)
ping_request = PingRequest(message="Hello, world!")
grpc_response = grpc_client.execute(
    ping_stub.Ping,
    ping_request,
    timeout=60,  # 60 seconds
)
```

### Custom Retry Logic

```python
from sift_client.wrapper.utils import retry, ServerError, RateLimitError
from sift_client.rest.client import RestClient, RestConfig

# Create a REST client configuration
config = RestConfig(
    base_url="api.sift.com",
    api_key="your-api-key",
)

# Create a REST client
client = RestClient(config)


@retry(
    max_retries=5,
    retry_delay=2.0,
    backoff_factor=3.0,
    retry_on=[ServerError, RateLimitError],
)
def make_request():
    # Make a request that might fail
    return client.get("/v1/users")
```

## License

This library is licensed under the MIT License. See the LICENSE file for details.
