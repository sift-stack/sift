#!/usr/bin/env python3
import sys
import importlib
import inspect
import pathlib
from typing import get_type_hints, Any

# Import registry of decorated classes
from sift_client._internal.sync_wrapper import _registered

HEADER = '''\
# Auto-generated stub
'''

CLASS_TEMPLATE = '''
class {cls_name}:
{doc}
{methods}
'''

METHOD_TEMPLATE = '''\
    def {meth_name}(self{params}){ret_ann}:
        """{meth_doc}"""
        ...
'''

def format_annotation(ann):
    if ann is inspect._empty:
        return ""
    if isinstance(ann, str):
        return ann
    origin = getattr(ann, "__origin__", None)
    if origin:
        args = ", ".join(format_annotation(a) for a in ann.__args__)
        name = getattr(origin, "__name__", repr(origin))
        return f"{name}[{args}]"
    if hasattr(ann, "__name__"):
        return ann.__name__
    return getattr(ann, "__qualname__", repr(ann))


def generate_stub_for_module(path_arg: str):
    cwd = pathlib.Path.cwd().resolve()
    candidate = pathlib.Path(path_arg)
    abs_path = (cwd / candidate).resolve()

    if abs_path.is_file():
        search_root = abs_path.parent
    elif abs_path.is_dir():
        search_root = abs_path
    else:
        raise ValueError(f"{path_arg!r} is neither a file nor a directory")

    for py in search_root.rglob("*.py"):
        if py.name.startswith("test_"):
            continue

        # Determine module name to import
        rel = py.with_suffix("").relative_to(cwd)
        module_name = ".".join(rel.parts)
        mod = importlib.import_module(module_name)

        lines = [HEADER]

        # Process only classes generated by @generate_sync_api
        sync_classes = {sync for async_, sync in _registered}

        for cls_name, cls in inspect.getmembers(mod, inspect.isclass):
            if cls not in sync_classes:
                continue

            # Find corresponding async class for imports
            async_cls = next(a for a, s in _registered if s is cls)
            # Read imports from the original async class module
            orig_path = pathlib.Path(inspect.getsourcefile(async_cls)).resolve()
            original_imports = []
            for line in orig_path.read_text().splitlines():
                if line.startswith("import ") or line.startswith("from "):
                    original_imports.append(line)
            if original_imports:
                original_imports.append("")
                lines += original_imports

            # Class docstring
            raw_doc = inspect.getdoc(cls) or ""
            if raw_doc:
                doc = '    """\n' + "\n".join(f"    {l}" for l in raw_doc.splitlines()) + "\n    \"\"\""
            else:
                doc = "    ..."

            methods = []
            for meth_name, meth in inspect.getmembers(cls, inspect.isfunction):
                sig = inspect.signature(meth)
                try:
                    hints = get_type_hints(meth, mod.__dict__, mod.__dict__)
                except NameError:
                    hints = {}

                # Parameters
                params = []
                for param in sig.parameters.values():
                    if param.name == "self":
                        continue
                    ann = hints.get(param.name, param.annotation)
                    ann_txt = format_annotation(ann)
                    default = ""
                    if param.default is not inspect._empty:
                        default = f" = {param.default!r}"
                    if ann_txt:
                        params.append(f", {param.name}: {ann_txt}{default}")
                    else:
                        params.append(f", {param.name}{default}")
                params_txt = "".join(params)

                # Return annotation
                ret_ann = hints.get("return", sig.return_annotation)
                ret_txt = ""
                if ret_ann is not inspect._empty:
                    ret_txt = f" -> {format_annotation(ret_ann)}"

                # Method docstring
                raw_mdoc = inspect.getdoc(meth) or ""
                meth_doc = raw_mdoc.replace('"""', '\\"\\"\\"').replace("\n", "\n        ")

                methods.append(
                    METHOD_TEMPLATE.format(
                        meth_name=meth_name,
                        params=params_txt,
                        ret_ann=ret_txt,
                        meth_doc=meth_doc,
                    )
                )

            stub = CLASS_TEMPLATE.format(
                cls_name=cls_name,
                doc=doc,
                methods="".join(methods),
            )
            lines.append(stub)

        pyi = py.with_suffix(".pyi")
        print(f"Writing stub: {pyi}")
        pyi.write_text("\n".join(lines))

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: gen_pyi.py <path/to/module-or-directory>")
        sys.exit(1)
    generate_stub_for_module(sys.argv[1])
