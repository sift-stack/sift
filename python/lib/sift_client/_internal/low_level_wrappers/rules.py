from __future__ import annotations

import logging
import re
from typing import Any, cast

from sift.rules.v1.rules_pb2 import (
    BatchDeleteRulesRequest,
    BatchGetRulesRequest,
    BatchGetRulesResponse,
    BatchUndeleteRulesRequest,
    BatchUpdateRulesRequest,
    BatchUpdateRulesResponse,
    CalculatedChannelConfig,
    ContextualChannels,
    CreateRuleRequest,
    CreateRuleResponse,
    DeleteRuleRequest,
    GetRuleRequest,
    GetRuleResponse,
    ListRulesRequest,
    RuleAssetConfiguration,
    RuleConditionExpression,
    SearchRulesRequest,
    SearchRulesResponse,
    UndeleteRuleRequest,
    UpdateConditionRequest,
    UpdateRuleRequest,
    UpdateRuleResponse,
)
from sift.rules.v1.rules_pb2 import (
    ChannelReference as ChannelReferenceProto,
)
from sift.rules.v1.rules_pb2_grpc import RuleServiceStub

from sift_client._internal.low_level_wrappers.base import LowLevelClientBase
from sift_client.transport.grpc_transport import GrpcClient
from sift_client.types.channel import ChannelReference
from sift_client.types.rule import (
    Rule,
    RuleAction,
    RuleUpdate,
)
from sift_client.util.cel_utils import *

# Configure logging
logger = logging.getLogger(__name__)


class RulesLowLevelClient(LowLevelClientBase):
    """
    Low-level client for the RulesAPI.

    This class provides a thin wrapper around the autogenerated bindings for the RulesAPI.
    """

    def __init__(self, grpc_client: GrpcClient):
        """
        Initialize the RulesLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        self._grpc_client = grpc_client

    async def get_rule(self, rule_id: str | None = None, client_key: str | None = None) -> Rule:
        """
        Get a rule by rule_id or client_key.

        Args:
            rule_id: The rule ID to get.
            client_key: The client key to get.

        Returns:
            The Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = GetRuleRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).GetRule(request)
        grpc_rule = cast(GetRuleResponse, response).rule
        return Rule._from_proto(grpc_rule)

    async def batch_get_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> list[Rule]:
        """
        Get multiple rules by rule_ids or client_keys.

        Args:
            rule_ids: List of rule IDs to get.
            client_keys: List of client keys to get.

        Returns:
            List of Rules.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchGetRulesRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchGetRules(request)
        response = cast(BatchGetRulesResponse, response)
        return [Rule._from_proto(rule) for rule in response.rules]

    async def create_rule(
        self,
        *,
        name: str,
        description: str,
        is_enabled: bool,
        organization_id: str,
        client_key: str,
        asset_ids: list[str] | None = None,
        tag_ids: list[str] | None = None,
        contextual_channels: list[str] | None = None,
        is_external: bool,
        expression: str,
        channel_references: list[ChannelReference],
        action: RuleAction,
    ) -> str:
        """
        Create a new rule.

        Args:
            name: The name of the rule.
            description: The description of the rule.
            is_enabled: Whether the rule is enabled.
            organization_id: The organization ID of the rule.
            client_key: The client key of the rule.
            asset_ids: The asset IDs of the rule.
            contextual_channels: Optional contextual channels of the rule.

        Returns:
            The rule ID of the created rule.
        """
        # TODO: Wrap these in reusable functions
        # Convert rule to UpdateRuleRequest
        expression_proto = RuleConditionExpression(
            calculated_channel=CalculatedChannelConfig(
                expression=expression,
                channel_references={
                    c.channel_reference: ChannelReferenceProto(name=c.channel_identifier)
                    for c in channel_references
                },
            )
        )
        conditions_request = [
            UpdateConditionRequest(expression=expression_proto, actions=[action.to_update_proto()])
        ]
        update_request = UpdateRuleRequest(
            name=name,
            description=description,
            is_enabled=is_enabled,
            organization_id=organization_id,
            client_key=client_key,
            is_external=is_external,
            conditions=conditions_request,
            asset_configuration=RuleAssetConfiguration(
                asset_ids=asset_ids or [],
                tag_ids=tag_ids or [],
            ),
            contextual_channels=ContextualChannels(channels=contextual_channels or []),
        )

        request = CreateRuleRequest(update=update_request)
        created_rule = cast(
            CreateRuleResponse,
            await self._grpc_client.get_stub(RuleServiceStub).CreateRule(request),
        )
        return await self.get_rule(rule_id=created_rule.rule_id, client_key=client_key)

    def _update_rule_request_from_update(self, rule: Rule, update: RuleUpdate, version_notes: str | None = None) -> UpdateRuleRequest:
        """
        Create an update request from a rule and update.

        This helper exists because the Rule update protos need a pattern that is less generic than the normal update + mask pattern of other types.
        """
        model_dump = update.model_dump(exclude_unset=True, exclude_none=False)

        update_dict = {
            "version_notes": version_notes,
        }
        nontrivial_updates = [
            "expression",
            "channel_references",
            "action",
            "contextual_channels",
            "asset_ids",
            "tag_ids",
        ]

        # Populate the non-trivial fields first.
        for updated_field, value in model_dump.items():
            if updated_field not in nontrivial_updates:
                update_dict[updated_field] = value

        # Special handling for the more complex fields.
        # Also, these must always be set.
        expression = model_dump.get("expression", rule.expression)
        channel_references = update.channel_references if "channel_references" in model_dump else rule.channel_references
        action = update.action if "action" in model_dump else rule.action
        expression_proto = RuleConditionExpression(
            calculated_channel=CalculatedChannelConfig(
                expression=expression,
                channel_references={
                    c.channel_reference: ChannelReferenceProto(name=c.channel_identifier)
                    for c in channel_references
                },
            )
        )
        conditions_request = [
            UpdateConditionRequest(expression=expression_proto, actions=[action.to_update_proto()])
        ]
        update_dict["conditions"] = conditions_request
        if "contextual_channels" in model_dump:
            update_dict["contextual_channels"] = ContextualChannels(
                channels=[ChannelReferenceProto(name=c) for c in update.contextual_channels or []]
            )

        # This always needs to be set, so handle the defaults.
        update_dict["asset_configuration"] = RuleAssetConfiguration(
            asset_ids=update.asset_ids if "asset_ids" in model_dump else rule.asset_ids or [],
            tag_ids=update.tag_ids if "tag_ids" in model_dump else rule.tag_ids or [],
        )

        update_request = UpdateRuleRequest(
            rule_id=rule.rule_id,
            **update_dict,
        )

        return update_request

    async def update_rule(self, rule: Rule, update: RuleUpdate, version_notes: str | None = None) -> Rule:
        """
        Update a rule.

        Args:
            rule: The rule to update.
            update: The update to apply.
            version_notes: Notes to include in the rule version.
        Returns:
            The updated Rule.
        """
        update.resource_id = rule.rule_id

        update_request = self._update_rule_request_from_update(rule, update, version_notes)

        response = await self._grpc_client.get_stub(RuleServiceStub).UpdateRule(update_request)
        updated_grpc_rule = cast(UpdateRuleResponse, response)
        # Get the updated rule
        return await self.get_rule(rule_id=updated_grpc_rule.rule_id)

    async def batch_update_rules(self, rules: list[RuleUpdate]) -> BatchUpdateRulesResponse:
        """
        Batch update rules.

        Args:
            rules: List of rule updates to apply.

        Returns:
            The batch update response.
        """
        update_requests = []
        for rule_update in rules:
            rule = await self.get_rule(rule_id=rule_update.resource_id)
            # TODO: Fix to_proto_with_mask for rules
            request = self._update_rule_request_from_update(rule, rule_update)
            update_requests.append(request)

        request = BatchUpdateRulesRequest(rules=update_requests)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchUpdateRules(request)
        return cast(BatchUpdateRulesResponse, response)

    async def delete_rule(self, rule_id: str | None = None, client_key: str | None = None) -> None:
        """
        Delete a rule.

        Args:
            rule_id: The rule ID to delete.
            client_key: The client key to delete.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = DeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).DeleteRule(request)

    async def batch_delete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch delete rules.

        Args:
            rule_ids: List of rule IDs to delete.
            client_keys: List of client keys to delete. If both are provided, rule_ids will be used.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchDeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchDeleteRules(request)

    async def undelete_rule(
        self, rule_id: str | None = None, client_key: str | None = None
    ) -> Rule:
        """
        Undelete a rule.

        Args:
            rule_id: The rule ID to undelete.
            client_key: The client key to undelete.

        Returns:
            The undeleted Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = UndeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).UndeleteRule(request)
        # Get the undeleted rule
        return await self.get_rule(rule_id=rule_id, client_key=client_key)

    async def batch_undelete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch undelete rules.

        Args:
            rule_ids: List of rule IDs to undelete.
            client_keys: List of client keys to undelete.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchUndeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchUndeleteRules(request)

    async def list_rules(
        self,
        *,
        name: str | None = None,
        name_contains: str | None = None,
        name_regex: str | re.Pattern | None = None,
        include_deleted: bool = False,
    ) -> list[Rule]:
        """
        List rules.
        """
        if int(name is not None) + int(name_contains is not None) + int(name_regex is not None) > 1:
            raise ValueError("Must use EITHER name, name_contains, or name_regex, not multiple")

        # TODO: Handle pagination
        # Available fields to filter by are `rule_id`, `client_key`, `name`, and `description`.
        filters = []
        if name:
            filters.append(equals("name", name))
        if name_contains:
            filters.append(contains("name", name_contains))
        if name_regex:
            filters.append(match("name", name_regex))
        if not include_deleted:
            filters.append(equals_null("deleted_date"))
        filter_str = " && ".join(filters) if filters else None
        request = ListRulesRequest(
            filter=filter_str,
        )
        response = await self._grpc_client.get_stub(RuleServiceStub).ListRules(request)
        return [Rule._from_proto(rule) for rule in response.rules]
