from __future__ import annotations

from datetime import datetime
import re
import logging
from typing import Any, cast
import inspect

from sift.rules.v1.rules_pb2 import (
    BatchDeleteRulesRequest,
    BatchGetRulesRequest,
    BatchGetRulesResponse,
    BatchUndeleteRulesRequest,
    BatchUpdateRulesRequest,
    BatchUpdateRulesResponse,
    CreateRuleRequest,
    CreateRuleResponse,
    DeleteRuleRequest,
    GetRuleRequest,
    GetRuleResponse,
    UpdateConditionRequest,
    SearchRulesRequest,
    SearchRulesResponse,
    UndeleteRuleRequest,
    UpdateRuleRequest,
    UpdateRuleResponse,
    RuleConditionExpression,
    CalculatedChannelConfig,
    ChannelReference as ChannelReferenceProto,
    ContextualChannels,
    ListRulesRequest,
)
from sift.rules.v1.rules_pb2_grpc import RuleServiceStub

from sift_client.util.cel_utils import *

from sift_client._internal.low_level_wrappers.base import LowLevelClientBase
from sift_client.transport.grpc_transport import GrpcClient
from sift_client.types.rule import (
    Rule,
    RuleAction,
    RuleAssetConfiguration,
    RuleCondition,
    RuleUpdate,
)
from sift_client.types.channel import ChannelReference

# Configure logging
logger = logging.getLogger(__name__)


class RulesLowLevelClient(LowLevelClientBase):
    """
    Low-level client for the RulesAPI.

    This class provides a thin wrapper around the autogenerated bindings for the RulesAPI.
    """

    def __init__(self, grpc_client: GrpcClient):
        """
        Initialize the RulesLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        self._grpc_client = grpc_client

    async def get_rule(self, rule_id: str | None = None, client_key: str | None = None) -> Rule:
        """
        Get a rule by rule_id or client_key.

        Args:
            rule_id: The rule ID to get.
            client_key: The client key to get.

        Returns:
            The Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = GetRuleRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).GetRule(request)
        grpc_rule = cast(GetRuleResponse, response).rule
        return Rule._from_proto(grpc_rule)

    async def batch_get_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> list[Rule]:
        """
        Get multiple rules by rule_ids or client_keys.

        Args:
            rule_ids: List of rule IDs to get.
            client_keys: List of client keys to get.

        Returns:
            List of Rules.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchGetRulesRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchGetRules(request)
        response = cast(BatchGetRulesResponse, response)
        return [Rule._from_proto(rule) for rule in response.rules]

    async def create_rule(
        self,
        *,
        name: str,
        description: str,
        is_enabled: bool,
        organization_id: str,
        client_key: str,
        asset_ids: list[str] | None = None,
        tag_ids: list[str] | None = None,
        contextual_channels: list[str] | None = None,
        is_external: bool,
        expression: str,
        channel_references: list[ChannelReference],
        action: RuleAction,
    ) -> str:
        """
        Create a new rule.

        Args:
            name: The name of the rule.
            description: The description of the rule.
            is_enabled: Whether the rule is enabled.
            organization_id: The organization ID of the rule.
            client_key: The client key of the rule.
            asset_ids: The asset IDs of the rule.
            contextual_channels: Optional contextual channels of the rule.

        Returns:
            The rule ID of the created rule.
        """
        # TODO: Wrap these in reusable functions
        # Convert rule to UpdateRuleRequest
        expression_proto = RuleConditionExpression(
            calculated_channel=CalculatedChannelConfig(
                expression=expression,
                channel_references={
                    c.channel_reference: ChannelReferenceProto(name=c.channel_identifier) for c in channel_references
                },
            )
        )
        conditions_request = [
            UpdateConditionRequest(expression=expression_proto, actions=[action.to_update_proto()])
        ]
        update_request = UpdateRuleRequest(
            name=name,
            description=description,
            is_enabled=is_enabled,
            organization_id=organization_id,
            client_key=client_key,
            is_external=is_external,
            conditions=conditions_request,
            asset_configuration=RuleAssetConfiguration(
                asset_ids=asset_ids or [],
                tag_ids=tag_ids or [],
            ),
            contextual_channels=ContextualChannels(channels=contextual_channels or []),
        )

        request = CreateRuleRequest(update=update_request)
        created_rule = cast(CreateRuleResponse, await self._grpc_client.get_stub(RuleServiceStub).CreateRule(request))
        return await self.get_rule(rule_id=created_rule.rule_id, client_key=client_key)

    def _update_rule_request_from_update(self, rule: Rule, update: RuleUpdate) -> UpdateRuleRequest:
        """
        Create an update request for a rule.
        """
        model_dump = update.model_dump(exclude_unset=True, exclude_none=False)
        print("Model dump:", model_dump)
        
        print("Update rule: grpc:", {k: v for k, v in model_dump.items() if v is not None})
        print("   src:", {k: v for k, v in rule.__dict__.items() if v is not None})
        # The Rule update protos need a pattern that is less generic than the normal update + mask pattern of other types.
        update_dict = {}
        channel_request_fields = ["expression", "channel_references", "action"]
        nontrivial_updates = channel_request_fields + ["contextual_channels", "asset_ids", "tag_ids"]
        # Populate the non-trivial fields first.
        for updated_field in model_dump.keys():
            if updated_field not in nontrivial_updates:
                update_dict[updated_field] = getattr(rule, updated_field)
        # Special handling for the more complex fields.
        if any(updated_field in model_dump.keys() for updated_field in channel_request_fields):
            expression = model_dump.get("expression", rule.expression)
            channel_references = model_dump.get("channel_references", rule.channel_references)
            action = model_dump.get("action", rule.action)
            expression_proto = RuleConditionExpression(
                calculated_channel=CalculatedChannelConfig(
                    expression=expression,
                    channel_references={
                        c.channel_reference: ChannelReferenceProto(name=c.channel_identifier) for c in channel_references
                    },
                )
            )
            conditions_request = [
                UpdateConditionRequest(expression=expression_proto, actions=[action.to_update_proto()])
            ]
            update_dict["conditions"] = conditions_request
        if "contextual_channels" in model_dump.keys():
            update_dict["contextual_channels"] = ContextualChannels(channels=update.contextual_channels or [])
        
        # This always needs to be set, so handle the defaults.
        update_dict["asset_configuration"] = RuleAssetConfiguration(
            asset_ids=model_dump.get("asset_ids", rule.asset_ids) or [],
            tag_ids=model_dump.get("tag_ids", rule.tag_ids) or [],
        )

        print("Update dict:", update_dict)

        update_request = UpdateRuleRequest(
            rule_id=rule.rule_id,
            **update_dict,
        )

        return update_request

    async def update_rule(self, rule: Rule, update: RuleUpdate) -> Rule:
        """
        Update a rule.

        Args:
            rule: The rule to update.
            update: The update to apply.

        Returns:
            The updated Rule.
        """
        update.resource_id = rule.rule_id
        
        update_request = self._update_rule_request_from_update(rule, update)

        response = await self._grpc_client.get_stub(RuleServiceStub).UpdateRule(update_request)
        updated_grpc_rule = cast(UpdateRuleResponse, response)
        # Get the updated rule
        return await self.get_rule(rule_id=updated_grpc_rule.rule_id)

    async def batch_update_rules(self, rules: list[RuleUpdate]) -> BatchUpdateRulesResponse:
        """
        Batch update rules.

        Args:
            rules: List of rule updates to apply.

        Returns:
            The batch update response.
        """
        update_requests = []
        for rule_update in rules:
            rule = await self.get_rule(rule_id=rule_update.resource_id)
            # TODO: Fix to_proto_with_mask for rules
            request = self._update_rule_request_from_update(rule, rule_update)
            update_requests.append(request)

        request = BatchUpdateRulesRequest(rules=update_requests)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchUpdateRules(request)
        return cast(BatchUpdateRulesResponse, response)

    async def delete_rule(self, rule_id: str | None = None, client_key: str | None = None) -> None:
        """
        Delete a rule.

        Args:
            rule_id: The rule ID to delete.
            client_key: The client key to delete.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = DeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).DeleteRule(request)

    async def batch_delete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch delete rules.

        Args:
            rule_ids: List of rule IDs to delete.
            client_keys: List of client keys to delete. If both are provided, rule_ids will be used.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchDeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchDeleteRules(request)

    async def undelete_rule(
        self, rule_id: str | None = None, client_key: str | None = None
    ) -> Rule:
        """
        Undelete a rule.

        Args:
            rule_id: The rule ID to undelete.
            client_key: The client key to undelete.

        Returns:
            The undeleted Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = UndeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).UndeleteRule(request)
        # Get the undeleted rule
        return await self.get_rule(rule_id=rule_id, client_key=client_key)

    async def batch_undelete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch undelete rules.

        Args:
            rule_ids: List of rule IDs to undelete.
            client_keys: List of client keys to undelete.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchUndeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchUndeleteRules(request)
    
    async def list_rules(
        self,
        *,
        name: str | None = None,
        name_contains: str | None = None,
        name_regex: str | re.Pattern | None = None,
    ) -> list[Rule]:
        """
        List rules.
        """
        if int(name is not None) + int(name_contains is not None) + int(name_regex is not None) > 1:
            raise ValueError("Must use EITHER name, name_contains, or name_regex, not multiple")
        
        # TODO: Handle pagination
        # Available fields to filter by are `rule_id`, `client_key`, `name`, and `description`.
        filters = []
        if name:
            filters.append(equals("name", name))
        if name_contains:
            filters.append(contains("name", name_contains))
        if name_regex:
            filters.append(match("name", name_regex))
        filter_str = " && ".join(filters) if filters else None
        request = ListRulesRequest(
            filter=filter_str,
        )
        response = await self._grpc_client.get_stub(RuleServiceStub).ListRules(request)
        return [Rule._from_proto(rule) for rule in response.rules]

    async def search_rules(
        self,
        name_matches: str | None = None,
        case_sensitive: bool = False,
        regexp: re.Pattern | None = None,
        order_by: str | None = None,
        rule_ids: list[str] | None = None,
        asset_ids: list[str] | None = None,
        include_deleted: bool = False,
        limit: int | None = None,
        offset: int = 0,
    ) -> tuple[list[Rule], int]:
        """
        Search for rules.

        Args:
            name_matches: Name pattern to match.
            case_sensitive: Whether the search is case sensitive.
            regexp: Whether to use regex matching.
            order_by: Field to order by.
            rule_ids: List of rule IDs to filter by.
            asset_ids: List of asset IDs to filter by.
            include_deleted: Whether to include deleted rules.
            limit: Maximum number of results to return.
            offset: Number of results to skip.

        Returns:
            Tuple of (list of Rules, total count).
        """
        request_kwargs: dict[str, Any] = {
            "offset": offset,
        }
        if name_matches is not None:
            request_kwargs["name_matches"] = name_matches
        if case_sensitive is not None:
            request_kwargs["case_sensitive"] = case_sensitive
        if regexp is not None:
            request_kwargs["regexp"] = True
        if order_by is not None:
            request_kwargs["order_by"] = order_by
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if asset_ids is not None:
            request_kwargs["asset_ids"] = asset_ids
        if include_deleted is not None:
            request_kwargs["include_deleted"] = include_deleted
        if limit is not None:
            request_kwargs["limit"] = limit

        request = SearchRulesRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).SearchRules(request)
        response = cast(SearchRulesResponse, response)
        return [Rule._from_proto(rule) for rule in response.rules], response.count
