from __future__ import annotations

import logging
from typing import Any, cast

from sift.rules.v1.rules_pb2 import (
    BatchDeleteRulesRequest,
    BatchGetRulesRequest,
    BatchGetRulesResponse,
    BatchUndeleteRulesRequest,
    BatchUpdateRulesRequest,
    BatchUpdateRulesResponse,
    CreateRuleRequest,
    CreateRuleResponse,
    DeleteRuleRequest,
    GetRuleRequest,
    GetRuleResponse,
    SearchRulesRequest,
    SearchRulesResponse,
    UndeleteRuleRequest,
    UpdateRuleRequest,
    UpdateRuleResponse,
)
from sift.rules.v1.rules_pb2_grpc import RuleServiceStub

from sift_client._internal.low_level_wrappers.base import LowLevelClientBase
from sift_client.transport.grpc_transport import GrpcClient
from sift_client.types.rule import Rule, RuleUpdate

# Configure logging
logger = logging.getLogger(__name__)


class RulesLowLevelClient(LowLevelClientBase):
    """
    Low-level client for the RulesAPI.

    This class provides a thin wrapper around the autogenerated bindings for the RulesAPI.
    """

    def __init__(self, grpc_client: GrpcClient):
        """
        Initialize the RulesLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        self._grpc_client = grpc_client

    async def get_rule(self, rule_id: str | None = None, client_key: str | None = None) -> Rule:
        """
        Get a rule by rule_id or client_key.

        Args:
            rule_id: The rule ID to get.
            client_key: The client key to get.

        Returns:
            The Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = GetRuleRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).GetRule(request)
        grpc_rule = cast(GetRuleResponse, response).rule
        return Rule._from_proto(grpc_rule)

    async def batch_get_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> list[Rule]:
        """
        Get multiple rules by rule_ids or client_keys.

        Args:
            rule_ids: List of rule IDs to get.
            client_keys: List of client keys to get.

        Returns:
            List of Rules.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchGetRulesRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchGetRules(request)
        response = cast(BatchGetRulesResponse, response)
        return [Rule._from_proto(rule) for rule in response.rules]

    async def create_rule(self, rule: Rule) -> str:
        """
        Create a new rule.

        Args:
            rule: The rule to create.

        Returns:
            The rule ID of the created rule.
        """
        # Convert rule to UpdateRuleRequest
        update_request = UpdateRuleRequest(
            name=rule.name,
            description=rule.description,
            is_enabled=rule.is_enabled,
            organization_id=rule.organization_id,
            client_key=rule.client_key,
            asset_configuration=rule.asset_configuration,
            contextual_channels=rule.contextual_channels,
            is_external=rule.is_external,
        )

        request = CreateRuleRequest(update=update_request)
        response = await self._grpc_client.get_stub(RuleServiceStub).CreateRule(request)
        return cast(CreateRuleResponse, response).rule_id

    async def update_rule(self, rule: Rule, update: RuleUpdate) -> Rule:
        """
        Update a rule.

        Args:
            rule: The rule to update.
            update: The update to apply.

        Returns:
            The updated Rule.
        """
        update.resource_id = rule.rule_id
        grpc_rule, update_mask = update.to_proto_with_mask()
        request = UpdateRuleRequest(
            rule_id=rule.rule_id,
            update_mask=update_mask,
            **{k: v for k, v in grpc_rule.__dict__.items() if v is not None},
        )
        response = await self._grpc_client.get_stub(RuleServiceStub).UpdateRule(request)
        updated_grpc_rule = cast(UpdateRuleResponse, response)
        # Get the updated rule
        return await self.get_rule(rule_id=updated_grpc_rule.rule_id)

    async def batch_update_rules(self, rules: list[RuleUpdate]) -> BatchUpdateRulesResponse:
        """
        Batch update rules.

        Args:
            rules: List of rule updates to apply.

        Returns:
            The batch update response.
        """
        update_requests = []
        for rule_update in rules:
            grpc_rule, update_mask = rule_update.to_proto_with_mask()
            request = UpdateRuleRequest(
                update_mask=update_mask,
                **{k: v for k, v in grpc_rule.__dict__.items() if v is not None},
            )
            update_requests.append(request)

        request = BatchUpdateRulesRequest(rules=update_requests)
        response = await self._grpc_client.get_stub(RuleServiceStub).BatchUpdateRules(request)
        return cast(BatchUpdateRulesResponse, response)

    async def delete_rule(self, rule_id: str | None = None, client_key: str | None = None) -> None:
        """
        Delete a rule.

        Args:
            rule_id: The rule ID to delete.
            client_key: The client key to delete.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = DeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).DeleteRule(request)

    async def batch_delete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch delete rules.

        Args:
            rule_ids: List of rule IDs to delete.
            client_keys: List of client keys to delete. If both are provided, rule_ids will be used.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchDeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchDeleteRules(request)

    async def undelete_rule(
        self, rule_id: str | None = None, client_key: str | None = None
    ) -> Rule:
        """
        Undelete a rule.

        Args:
            rule_id: The rule ID to undelete.
            client_key: The client key to undelete.

        Returns:
            The undeleted Rule.

        Raises:
            ValueError: If neither rule_id nor client_key is provided.
        """
        if rule_id is None and client_key is None:
            raise ValueError("Either rule_id or client_key must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_id is not None:
            request_kwargs["rule_id"] = rule_id
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = UndeleteRuleRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).UndeleteRule(request)
        # Get the undeleted rule
        return await self.get_rule(rule_id=rule_id, client_key=client_key)

    async def batch_undelete_rules(
        self, rule_ids: list[str] | None = None, client_keys: list[str] | None = None
    ) -> None:
        """
        Batch undelete rules.

        Args:
            rule_ids: List of rule IDs to undelete.
            client_keys: List of client keys to undelete.

        Raises:
            ValueError: If neither rule_ids nor client_keys is provided.
        """
        if rule_ids is None and client_keys is None:
            raise ValueError("Either rule_ids or client_keys must be provided")

        request_kwargs: dict[str, Any] = {}
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if client_keys is not None:
            request_kwargs["client_keys"] = client_keys

        request = BatchUndeleteRulesRequest(**request_kwargs)
        await self._grpc_client.get_stub(RuleServiceStub).BatchUndeleteRules(request)

    async def search_rules(
        self,
        name_matches: str | None = None,
        case_sensitive: bool = False,
        regexp: bool = False,
        order_by: str | None = None,
        rule_ids: list[str] | None = None,
        asset_ids: list[str] | None = None,
        include_deleted: bool = False,
        limit: int | None = None,
        offset: int = 0,
    ) -> tuple[list[Rule], int]:
        """
        Search for rules.

        Args:
            name_matches: Name pattern to match.
            case_sensitive: Whether the search is case sensitive.
            regexp: Whether to use regex matching.
            order_by: Field to order by.
            rule_ids: List of rule IDs to filter by.
            asset_ids: List of asset IDs to filter by.
            include_deleted: Whether to include deleted rules.
            limit: Maximum number of results to return.
            offset: Number of results to skip.

        Returns:
            Tuple of (list of Rules, total count).
        """
        request_kwargs: dict[str, Any] = {
            "offset": offset,
        }
        if name_matches is not None:
            request_kwargs["name_matches"] = name_matches
        if case_sensitive is not None:
            request_kwargs["case_sensitive"] = case_sensitive
        if regexp is not None:
            request_kwargs["regexp"] = regexp
        if order_by is not None:
            request_kwargs["order_by"] = order_by
        if rule_ids is not None:
            request_kwargs["rule_ids"] = rule_ids
        if asset_ids is not None:
            request_kwargs["asset_ids"] = asset_ids
        if include_deleted is not None:
            request_kwargs["include_deleted"] = include_deleted
        if limit is not None:
            request_kwargs["limit"] = limit

        request = SearchRulesRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(RuleServiceStub).SearchRules(request)
        response = cast(SearchRulesResponse, response)
        return [Rule._from_proto(rule) for rule in response.rules], response.count
