from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any, cast

from sift.runs.v2.runs_pb2 import (
    CreateAutomaticRunAssociationForAssetsRequest,
    CreateRunResponse,
    GetRunRequest,
    GetRunResponse,
    ListRunsRequest,
    ListRunsResponse,
    StopRunRequest,
    UpdateRunRequest,
    UpdateRunResponse,
)
from sift.runs.v2.runs_pb2_grpc import RunServiceStub

from sift_client._internal.low_level_wrappers.base import LowLevelClientBase
from sift_client.sift_types.run import Run, RunCreate, RunUpdate
from sift_client.transport import WithGrpcClient

if TYPE_CHECKING:
    from sift_client.transport.grpc_transport import GrpcClient

# Configure logging
logger = logging.getLogger(__name__)


class RunsLowLevelClient(LowLevelClientBase, WithGrpcClient):
    """Low-level client for the RunsAPI.

    This class provides a thin wrapper around the autogenerated bindings for the RunsAPI.
    """

    def __init__(self, grpc_client: GrpcClient):
        """Initialize the RunsLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        super().__init__(grpc_client)

    async def get_run(
        self,
        run_id: str,
        *,
        force_refresh: bool = False,
    ) -> Run:
        """Get a run by run_id.

        Args:
            run_id: The run ID to get.
            metadata: Optional gRPC metadata including cache control.

        Returns:
            The Run.

        Raises:
            ValueError: If run_id is not provided.
        """
        request = GetRunRequest(run_id=run_id)
        stub = self._grpc_client.get_stub(RunServiceStub)
        response = await self.call_with_cache(
            stub.GetRun,
            request,
            use_cache=self._grpc_client.has_cache,
            force_refresh=force_refresh,
        )
        grpc_run = cast("GetRunResponse", response).run
        return Run._from_proto(grpc_run)

    async def list_runs(
        self,
        *,
        page_size: int | None = None,
        page_token: str | None = None,
        query_filter: str | None = None,
        order_by: str | None = None,
        force_refresh: bool = False,
    ) -> tuple[list[Run], str]:
        """List runs with optional filtering and pagination.

        Args:
            page_size: The maximum number of runs to return.
            page_token: A page token for pagination.
            query_filter: A CEL filter string.
            order_by: How to order the retrieved runs.

        Returns:
            A tuple of (runs, next_page_token).
        """
        request_kwargs: dict[str, Any] = {}
        if page_size is not None:
            request_kwargs["page_size"] = page_size
        if page_token is not None:
            request_kwargs["page_token"] = page_token
        if query_filter is not None:
            request_kwargs["filter"] = query_filter
        if order_by is not None:
            request_kwargs["order_by"] = order_by

        request = ListRunsRequest(**request_kwargs)
        stub = self._grpc_client.get_stub(RunServiceStub)
        response = await self.call_with_cache(
            stub.ListRuns,
            request,
            use_cache=self._grpc_client.has_cache,
            force_refresh=force_refresh,
        )
        response = cast("ListRunsResponse", response)

        runs = [Run._from_proto(run) for run in response.runs]
        return runs, response.next_page_token

    async def list_all_runs(
        self,
        *,
        query_filter: str | None = None,
        order_by: str | None = None,
        max_results: int | None = None,
        force_refresh: bool = False,
    ) -> list[Run]:
        """List all runs with optional filtering.

        Args:
            query_filter: A CEL filter string.
            order_by: How to order the retrieved runs.
            max_results: Maximum number of results to return.

        Returns:
            A list of all matching runs.
        """
        return await self._handle_pagination(
            lambda **k: self.list_runs(
                **k,
                query_filter=query_filter,
                order_by=order_by,
                force_refresh=force_refresh,
            ),
            kwargs={},
            order_by=order_by,
            max_results=max_results,
        )

    async def create_run(self, *, create: RunCreate) -> Run:
        request_proto = create.to_proto()
        response = await self._grpc_client.get_stub(RunServiceStub).CreateRun(request_proto)
        grpc_run = cast("CreateRunResponse", response).run
        return Run._from_proto(grpc_run)

    async def update_run(self, update: RunUpdate) -> Run:
        grpc_run, update_mask = update.to_proto_with_mask()
        request = UpdateRunRequest(run=grpc_run, update_mask=update_mask)
        response = await self._grpc_client.get_stub(RunServiceStub).UpdateRun(request)
        updated_grpc_run = cast("UpdateRunResponse", response).run
        return Run._from_proto(updated_grpc_run)

    async def stop_run(self, run_id: str) -> None:
        """Stop a run by setting its stop time to the current time.

        Args:
            run_id: The ID of the run to stop.

        Raises:
            ValueError: If run_id is not provided.
        """
        if not run_id:
            raise ValueError("run_id must be provided")

        request = StopRunRequest(run_id=run_id)
        await self._grpc_client.get_stub(RunServiceStub).StopRun(request)

    async def create_automatic_run_association_for_assets(
            self, run_id: str, asset_names: list[str]
    ) -> None:
        """Associate assets with a run for automatic data ingestion.

        Args:
            run_id: The ID of the run.
            asset_names: List of asset names to associate.

        Raises:
            ValueError: If run_id or asset_names are not provided.
        """
        if not run_id:
            raise ValueError("run_id must be provided")
        if not asset_names:
            raise ValueError("asset_names must be provided")

        request = CreateAutomaticRunAssociationForAssetsRequest(
            run_id=run_id, asset_names=asset_names
        )
        await self._grpc_client.get_stub(RunServiceStub).CreateAutomaticRunAssociationForAssets(
            request
        )
