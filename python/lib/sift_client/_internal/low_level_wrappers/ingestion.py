"""
Low-level wrapper for the IngestionAPI.

This module provides thin wrappers around the autogenerated bindings for the IngestionAPI.
It handles common concerns like error handling and retries.

It provides an asynchronous client for the IngestionAPI.
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Any, List, cast

from sift.ingest.v1.ingest_pb2 import (
    IngestArbitraryProtobufDataStreamResponse,
    IngestWithConfigDataStreamRequest,
)
from sift.ingest.v1.ingest_pb2_grpc import IngestServiceStub
from sift.ingestion_configs.v2.ingestion_configs_pb2 import (
    CreateIngestionConfigRequest,
    CreateIngestionConfigResponse,
)
from sift.ingestion_configs.v2.ingestion_configs_pb2_grpc import IngestionConfigServiceStub

from sift_client._internal.low_level_wrappers.base import (
    LowLevelClientBase,
)
from sift_client.transport import GrpcClient, WithGrpcClient
from sift_client.types.channel import ChannelDataType, Flow
from sift_client.util.timestamp import to_pb_timestamp

# Configure logging
logger = logging.getLogger(__name__)


class IngestionLowLevelClient(LowLevelClientBase, WithGrpcClient):
    """
    Low-level client for the IngestionAPI.

    This class provides a thin wrapper around the autogenerated bindings for the IngestionAPI.
    It handles common concerns like error handling and retries.
    """

    def __init__(self, grpc_client: GrpcClient):
        """
        Initialize the IngestionLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        super().__init__(grpc_client=grpc_client)

    async def create_ingestion_config(
        self,
        *,
        asset_name: str,
        flows: List[Flow],
        client_key: str | None = None,
        organization_id: str | None = None,
    ) -> str:
        """
        Create an ingestion config.
        """
        req = CreateIngestionConfigRequest(
            asset_name=asset_name,
            flows=[flow.to_proto() for flow in flows],
            organization_id=organization_id or "",
            client_key=client_key or "",
        )
        res = await self._grpc_client.get_stub(IngestionConfigServiceStub).CreateIngestionConfig(
            req
        )
        res = cast(CreateIngestionConfigResponse, res)
        ingestion_config_id = res.ingestion_config.ingestion_config_id
        for flow in flows:
            flow.ingestion_config_id = ingestion_config_id
        return ingestion_config_id

    async def ingest_flow(self, *, flow: Flow, time: datetime, channel_values: dict[str, Any]):
        """
        Ingest a flow.
        """
        proto_channel_values = []
        # Iterate through all expected channels for flow and convert to ingestion types (missing channels use a special empty type)
        for channel in flow.channels:
            val = channel_values.get(channel.name)
            if channel.data_type == ChannelDataType.ENUM and isinstance(val, str):
                for enum_type in channel.enum_types or []:
                    if enum_type.name == val:
                        val = enum_type.key
                        break
            elif channel.data_type == ChannelDataType.BIT_FIELD:
                # TODO: Handle bit field values correctly
                val = None
            proto_channel_values.append(ChannelDataType.to_ingestion_value(channel.data_type, val))

        print(
            f"Ingesting flow {flow.name} with config id {flow.ingestion_config_id} at {time} with values {proto_channel_values}"
        )
        if not flow.ingestion_config_id:
            raise ValueError(
                "Flow has no ingestion config id -- have you created an ingestion config for this flow?"
            )

        req = IngestWithConfigDataStreamRequest(
            ingestion_config_id=flow.ingestion_config_id,
            flow=flow.name,
            timestamp=to_pb_timestamp(time),
            channel_values=proto_channel_values,
        )
        self._grpc_client.get_stub(IngestServiceStub).IngestWithConfigDataStream(req)

    async def ingest_arbitrary_protobuf_data_stream(
        self,
    ) -> IngestArbitraryProtobufDataStreamResponse:
        """
        Stream arbitrary protobuf data for ingestion.

        Returns:
            The ingestion response.
        """
        raise NotImplementedError("Not implemented")
