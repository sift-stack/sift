from __future__ import annotations

import logging
from typing import Any, cast

from sift.calculated_channels.v2.calculated_channels_pb2 import (
    BatchResolveCalculatedChannelsRequest,
    BatchResolveCalculatedChannelsResponse,
    CalculatedChannelAbstractChannelReference,
    CalculatedChannelAssetConfiguration,
    CalculatedChannelConfiguration,
    CalculatedChannelQueryConfiguration,
    CalculatedChannelValidationResult,
    CreateCalculatedChannelRequest,
    CreateCalculatedChannelResponse,
    GetCalculatedChannelRequest,
    GetCalculatedChannelResponse,
    ListCalculatedChannelsRequest,
    ListCalculatedChannelsResponse,
    ListCalculatedChannelVersionsRequest,
    ListCalculatedChannelVersionsResponse,
    ResolveCalculatedChannelRequest,
    ResolveCalculatedChannelResponse,
    UpdateCalculatedChannelRequest,
    UpdateCalculatedChannelResponse,
)
from sift.calculated_channels.v2.calculated_channels_pb2_grpc import CalculatedChannelServiceStub

from sift_client._internal.low_level_wrappers.base import LowLevelClientBase
from sift_client.transport.grpc_transport import GrpcClient
from sift_client.types.calculated_channel import (
    CalculatedChannel,
    CalculatedChannelUpdate,
)
from sift_client.types.channel import ChannelReference

# Configure logging
logger = logging.getLogger(__name__)


class CalculatedChannelsLowLevelClient(LowLevelClientBase):
    """
    Low-level client for the CalculatedChannelsAPI.

    This class provides a thin wrapper around the autogenerated bindings for the CalculatedChannelsAPI.
    """

    def __init__(self, grpc_client: GrpcClient):
        """
        Initialize the CalculatedChannelsLowLevelClient.

        Args:
            grpc_client: The gRPC client to use for making API calls.
        """
        self._grpc_client = grpc_client

    async def get_calculated_channel(
        self,
        calculated_channel_id: str | None = None,
        client_key: str | None = None,
        organization_id: str | None = None,
    ) -> CalculatedChannel:
        """
        Get a calculated channel by ID or client key.

        Args:
            calculated_channel_id: The ID of the calculated channel.
            client_key: The client key of the calculated channel.
            organization_id: The organization ID (required if using client_key and user belongs to multiple organizations).

        Returns:
            The CalculatedChannel.

        Raises:
            ValueError: If neither calculated_channel_id nor client_key is provided.
        """
        if calculated_channel_id:
            request = GetCalculatedChannelRequest(calculated_channel_id=calculated_channel_id)
        elif client_key:
            request = GetCalculatedChannelRequest(
                client_key=client_key, organization_id=organization_id
            )
        else:
            raise ValueError("Either calculated_channel_id or client_key must be provided")

        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).GetCalculatedChannel(request)
        grpc_calculated_channel = cast(GetCalculatedChannelResponse, response).calculated_channel
        return CalculatedChannel._from_proto(grpc_calculated_channel)

    async def create_calculated_channel(
        self,
        name: str,
        all_assets: bool = False,
        asset_ids: list[str] | None = None,
        tag_ids: list[str] | None = None,
        expression: str = "",
        channel_references: list[ChannelReference] = [],
        description: str = "",
        user_notes: str = "",
        units: str | None = None,
        client_key: str | None = None,
    ) -> tuple[CalculatedChannel, list[Any]]:  # Returns (calculated_channel, inapplicable_assets)
        """
        Create a calculated channel.

        Args:
            name: The name of the calculated channel.
            calculated_channel_configuration: The configuration for the calculated channel.
            description: The description of the calculated channel.
            user_notes: User notes for the calculated channel.
            units: The units for the calculated channel.
            client_key: A user-defined unique identifier for the calculated channel.

        Returns:
            A tuple of (CalculatedChannel, list of inapplicable assets).
        """
        # TODO: Try to use model_dump() to build the proto
        asset_config = CalculatedChannelAssetConfiguration(
            all_assets=all_assets,
            selection=CalculatedChannelAssetConfiguration.AssetSelection(
                asset_ids=asset_ids,
                tag_ids=tag_ids,
            ),
        )
        request_kwargs: dict[str, Any] = {
            "name": name,
            "description": description,
            "user_notes": user_notes,
            "calculated_channel_configuration": CalculatedChannelConfiguration(
                asset_configuration=asset_config,
                query_configuration=CalculatedChannelQueryConfiguration(
                    sel=CalculatedChannelQueryConfiguration.Sel(
                        expression=expression,
                        expression_channel_references=[
                            CalculatedChannelAbstractChannelReference(
                                channel_identifier=ref.channel_name,
                                channel_reference=ref.reference_key,
                            )
                            for ref in channel_references
                        ],
                    ),
                ),
            ),
        }
        if units is not None:
            request_kwargs["units"] = units
        if client_key is not None:
            request_kwargs["client_key"] = client_key

        request = CreateCalculatedChannelRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).CreateCalculatedChannel(request)
        response = cast(CreateCalculatedChannelResponse, response)

        calculated_channel = CalculatedChannel._from_proto(response.calculated_channel)
        inapplicable_assets = list(response.inapplicable_assets)

        return calculated_channel, inapplicable_assets

    async def list_all_calculated_channels(
        self,
        query_filter: str | None = None,
        order_by: str | None = None,
        max_results: int | None = None,
        page_size: int | None = None,
        organization_id: str | None = None,
    ) -> list[CalculatedChannel]:
        """
        List all calculated channels matching the given query.

        Args:
            query_filter: The CEL query filter.
            order_by: The field to order by.
            max_results: The maximum number of results to return.
            page_size: The number of results to return per page.
            organization_id: The organization ID (required if user belongs to multiple organizations).

        Returns:
            A list of CalculatedChannels matching the given query.
        """
        return await self._handle_pagination(
            self.list_calculated_channels,
            kwargs={"organization_id": organization_id},
            page_size=page_size,
            query_filter=query_filter,
            order_by=order_by,
            max_results=max_results,
        )

    async def list_calculated_channels(
        self,
        page_size: int | None = None,
        page_token: str | None = None,
        query_filter: str | None = None,
        order_by: str | None = None,
        organization_id: str | None = None,
    ) -> tuple[list[CalculatedChannel], str]:
        """
        List calculated channels with pagination.

        Args:
            page_size: The number of results to return per page.
            page_token: The page token for pagination.
            query_filter: The CEL query filter.
            order_by: The field to order by.
            organization_id: The organization ID.

        Returns:
            A tuple of (list of CalculatedChannels, next_page_token).
        """
        request_kwargs: dict[str, Any] = {}
        if page_size is not None:
            request_kwargs["page_size"] = page_size
        if page_token is not None:
            request_kwargs["page_token"] = page_token
        if query_filter is not None:
            request_kwargs["filter"] = query_filter
        if order_by is not None:
            request_kwargs["order_by"] = order_by
        if organization_id is not None:
            request_kwargs["organization_id"] = organization_id

        request = ListCalculatedChannelsRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).ListCalculatedChannels(request)
        response = cast(ListCalculatedChannelsResponse, response)

        calculated_channels = [
            CalculatedChannel._from_proto(cc) for cc in response.calculated_channels
        ]
        return calculated_channels, response.next_page_token

    async def update_calculated_channel(
        self, update: CalculatedChannelUpdate, user_notes: str | None = None
    ) -> tuple[CalculatedChannel, list[Any]]:  # Returns (calculated_channel, inapplicable_assets)
        """
        Update a calculated channel.

        Args:
            update: The CalculatedChannelUpdate to apply.
            user_notes: User notes for the update.

        Returns:
            A tuple of (updated CalculatedChannel, list of inapplicable assets).
        """
        grpc_calculated_channel, update_mask = update.to_proto_with_mask()
        print(type(grpc_calculated_channel))
        request = UpdateCalculatedChannelRequest(
            calculated_channel=grpc_calculated_channel,
            update_mask=update_mask,
            user_notes=user_notes,
        )
        print("request", request)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).UpdateCalculatedChannel(request)
        response = cast(UpdateCalculatedChannelResponse, response)

        updated_calculated_channel = CalculatedChannel._from_proto(response.calculated_channel)
        # TODO: Handle CalculatedChannelValidationResult in a friendlier way -- maybe break out the components and handle in the resource
        inapplicable_assets = cast(CalculatedChannelValidationResult, response.inapplicable_assets)

        return updated_calculated_channel, inapplicable_assets

    async def list_calculated_channel_versions(
        self,
        calculated_channel_id: str | None = None,
        client_key: str | None = None,
        organization_id: str | None = None,
        page_size: int | None = None,
        page_token: str | None = None,
        query_filter: str | None = None,
        order_by: str | None = None,
    ) -> tuple[list[CalculatedChannel], str]:
        """
        List versions of a calculated channel.

        Args:
            calculated_channel_id: The ID of the calculated channel.
            client_key: The client key of the calculated channel.
            organization_id: The organization ID.
            page_size: The number of results to return per page.
            page_token: The page token for pagination.
            query_filter: The CEL query filter.
            order_by: The field to order by.

        Returns:
            A tuple of (list of CalculatedChannel versions, next_page_token).

        Raises:
            ValueError: If neither calculated_channel_id nor client_key is provided.
        """
        if calculated_channel_id:
            request_kwargs = {"calculated_channel_id": calculated_channel_id}
        elif client_key:
            request_kwargs = {"client_key": client_key, "organization_id": organization_id}
        else:
            raise ValueError("Either calculated_channel_id or client_key must be provided")

        if page_size is not None:
            request_kwargs["page_size"] = page_size
        if page_token is not None:
            request_kwargs["page_token"] = page_token
        if query_filter is not None:
            request_kwargs["filter"] = query_filter
        if order_by is not None:
            request_kwargs["order_by"] = order_by

        request = ListCalculatedChannelVersionsRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).ListCalculatedChannelVersions(request)
        response = cast(ListCalculatedChannelVersionsResponse, response)

        versions = [
            CalculatedChannel._from_proto(cc) for cc in response.calculated_channel_versions
        ]
        return versions, response.next_page_token

    async def resolve_calculated_channel(
        self,
        identifier: Any | None = None,  # ResourceIdentifier from protobuf
        calculated_channel_configuration: Any
        | None = None,  # CalculatedChannelConfiguration from protobuf
        organization_id: str | None = None,
        assets: Any | None = None,  # NamedResources from protobuf
        run: Any | None = None,  # ResourceIdentifier from protobuf
    ) -> ResolveCalculatedChannelResponse:
        """
        Resolve a calculated channel into an expression with references.

        Args:
            identifier: The resource identifier.
            calculated_channel_configuration: The calculated channel configuration.
            organization_id: The organization ID.
            assets: The assets to resolve against.
            run: The run to resolve against.

        Returns:
            The ResolveCalculatedChannelResponse.

        Raises:
            ValueError: If neither identifier nor calculated_channel_configuration is provided.
        """
        if identifier:
            request_kwargs = {"identifier": identifier}
        elif calculated_channel_configuration:
            request_kwargs = {"calculated_channel_configuration": calculated_channel_configuration}
        else:
            raise ValueError(
                "Either identifier or calculated_channel_configuration must be provided"
            )

        if organization_id is not None:
            request_kwargs["organization_id"] = organization_id
        if assets is not None:
            request_kwargs["assets"] = assets
        if run is not None:
            request_kwargs["run"] = run

        request = ResolveCalculatedChannelRequest(**request_kwargs)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).ResolveCalculatedChannel(request)
        return cast(ResolveCalculatedChannelResponse, response)

    async def batch_resolve_calculated_channels(
        self, requests: list[ResolveCalculatedChannelRequest]
    ) -> BatchResolveCalculatedChannelsResponse:
        """
        Resolve a batch of calculated channels into expressions with references.

        Args:
            requests: A list of ResolveCalculatedChannelRequest objects.

        Returns:
            The BatchResolveCalculatedChannelsResponse.
        """
        request = BatchResolveCalculatedChannelsRequest(requests=requests)
        response = await self._grpc_client.get_stub(
            CalculatedChannelServiceStub
        ).BatchResolveCalculatedChannels(request)
        return cast(BatchResolveCalculatedChannelsResponse, response)
