## **RFC 114: High-Level Python Client for Sift (sift-py)**

| Status | Draft |
| :---- | :---- |
| **Owner** | [Alex Luck](mailto:luck@siftstack.com) |
| **Contributors** | [Benjamin Nguyen](mailto:benjamin@siftstack.com)[Ailin Yu](mailto:ailin@siftstack.com)[Marc Daniel Julien](mailto:marc@siftstack.com) |
| **Approvers** |  |
| **PRDs** | [PRD 044: High-level Python Client](https://siftstack.atlassian.net/wiki/spaces/ENG/pages/851902469/PRD+044+High-level+Python+Client) |

Changes:

| May 9, 2025 | Implement feedback from RFC discussion |
| :---- | :---- |
|  |  |

### **Proposal**

Implement a notebook-friendly, high-level Python client (`sift-py`) for interacting with the Sift backend, designed with clear abstractions and enhanced usability compared to the current `sift-py` implementation. Additionally, the goal is reduce the user facing surface area of the library to improve maintainability. The new architecture will explicitly separate concerns into three clearly defined layers:

* **Autogenerated gRPC API (public-facing):** Existing protoc-generated bindings.  
* **Low-Level API (internal):** Thin wrappers around autogenerated bindings with structured Python classes for Sift data constructs.  
* **High-Level API (public-facing):** Pythonic, notebook-friendly interface emphasizing ease of use, automatic handling of gRPC services, seamless type conversion, and clear error handling.

Additionally, publish Python bindings/binary for using Rust [`sift_stream`](https://github.com/sift-stack/sift/tree/main/rust/crates/sift_stream) (`sift-stream-python-bindings`) as a separate PyPI package. This can then be used in place of the async gRPC streaming implementation and leverage features, such as checkpointing/retries, as well as improved performance of Rust.

### **Why build it?**

The existing Sift Python client (`sift-py`) suffers from:

* High complexity and verbosity requiring extensive gRPC knowledge or limited API access via provided higher-level wrappers.  
* Difficult-to-understand errors directly exposed from gRPC.  
* Lack of Pythonic idioms and intuitive user experience.  
* Large user facing surface area (autogen code, many services, etc.) with addition of new high-level API

By addressing these issues, we expect to:

* Significantly reduce onboarding friction for new users, especially hardware engineers and analysts.  
* Improve developer productivity and user satisfaction through more intuitive interactions, further abstraction from gRPC types.  
* Maintain clear separations of concerns, allowing independent iteration on the autogenerated gRPC code and potential future adoption of better tooling like BetterProto2.

### **Infrastructure**

* **Repositories:**  
  * `sift-py`: Contains the high-level API, internal only low-level API, and autogen code.  
  * `sift-stream-python-bindings`: Separate PyPI package for streaming ingestion Rust bindings and associated binaries.  
* **Build System:** GitHub Actions with automated PyPI deployment.  
* **Documentation:** Auto-generated via MkDocs, published automatically.

### **Breaking Changes**

Initial development will be incremental and legacy sift-py services kept with deprecation warnings. Once high-level is stable and complete, plan to remove current sift-py services and interfaces.

This proposal introduces several breaking changes:

* **High-Level API becomes default interaction mode.**  
  * **Why acceptable:** Simplifies interaction for majority of users (estimated \>80% use-cases).  
* **Transition to Python 3.10+ style typing.**  
  * **Why acceptable:** Type hints can be updated to conform with Python 3.10+ standards and maintain backwards compatibility by using `from __future__ import annotations` and Pydantic with `eval-type-backport`.   
* **Deprecation of current `sift-py` services:** Existing services will remain temporarily, clearly marked as deprecated until full removal in a major release.

### **Monitoring & Logging**

* Add user-agent to requests, e.g. `sift-py/X.X.X`  
  * Include information about user’s Python version  
* Additional request metrics may be useful in the future but out of scope of this release  
  * Which functions users are calling directly, for example

### **Performance**

* Continue to use grpc/grpcio via protoc autogenerated code for time being, no performance change  
* Use separately packaged Rust-based `sift-stream-python-bindings` library for efficient streaming ingestion, offloading performance-sensitive tasks.

### **User Interaction & Design**

* Domain classes with clear representation (`Asset`, `Run`, `Annotation`).  
* Simplified methods like `search`, `find`, `get_data`, etc.  
* Clear, context-specific exceptions with actionable error messages.  
* Full type hinting and rich documentation for IDE integration.  
  * [Google style docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)  
  * [Mkdocs](https://www.mkdocs.org/) with [mkdocstrings](https://mkdocstrings.github.io/)

### **Implementation**

To avoid a monolithic client design, the high-level API will adopt a resource-oriented approach, aligning with industry-standard SDK patterns (e.g., Google Cloud Python SDK, AWS Boto3, Stripe). This approach ensures:

* **User-friendliness:** Clear namespace separation for intuitive API interactions.  
  * E.g. `sift.views`, `sift.annotations`, `sift.assets`, `sift.data`  
* **Maintainability:** Smaller classes that encapsulate specific logic, simplifying updates and debugging.  
* **Extensibility:** Easy to add or modify resource-specific functionality without affecting unrelated code.

**Class Structure Example:**

*Note: for example purposes only, exact implementation (args, returns) subject to change.*

```py
class SiftClient:
    def __init__(self, api_key: str, endpoint: str = "https://api.sift.com"):
        """Initializes the Sift client, authenticates, and sets up service endpoints."""
        self.api_key = api_key
        self.endpoint = endpoint
        self.assets = AssetsAPI(self)
        self.views = ViewsAPI(self)
        self.data = DataAPI(self)

class AssetsAPI:
    def __init__(self, client: SiftClient):
        self.client = client

    def create(self, name: str, tags: list[str]) -> Asset:
        """Creates a new asset with the given name and tags."""
        pass

    def list(self, name: str = None, created_by: str = None, tags: list[str] = None) -> List[Asset]:
        """Lists assets optionally filtered by specific parameters."""
        pass

    def find(self, asset_id: str = None, name: str = None, tags: list[str] = None) -> Asset:
        """Finds a specific asset using various identifiers. Errors if more than one asset matches."""
        pass

    def update(self, asset_id: str, tags: list[str]) -> Asset:
        """Updates the tags of the specified asset."""
        pass

    def archive(self, asset_id: str) -> None:
        """Archives the specified asset, making it inactive but retaining its data."""
        pass

class ViewsAPI:
    def __init__(self, client: SiftClient):
        self.client = client

    def create(self, definition: dict) -> View:
        pass

    def list(self, name: str = None, created_by: str = None) -> List[View]:
        pass

    def update(self, view_id: str, updates: dict) -> View:
        pass

    def archive(self, view_id: str) -> None:
        pass

class DataAPI:
    def __init__(self, client: SiftClient):
        self.client = client

    def get_data(self, assets: list[Asset] | list[str] = None, channels: list[Channel] | list[str] = None, runs: list[Run] | list[str]) -> pd.DataFrame:
        pass
```

```py
from sift_py import SiftClient

# Initialize the client
sift = SiftClient(api_key="YOUR_API_KEY")

# Create a new asset
new_asset: Asset = sift.assets.create(
	name="Experiment-123",
	tags=["alpha", "test-run"]
)
print(f"Created asset {new_asset.asset_id} with name '{new_asset.name}'")

# List all assets whose name starts with “Experiment”
assets = sift.assets.list(name=r"^Experiment.*")
for asset in assets:
	print(f"- {asset.asset_id}: {asset.name} (tags: {asset.tags})")

# Get runs associated with an asset
runs: list[Run] = assets[0].runs

# Get channels associated with an asset
channels: list[Channel] = assets[0].channels


```

### 

### **Alternative Proposals**

#### **1\. Autogen Code Comparison**

We need a maintainable, idiomatic Python binding for gRPC. Three options were evaluated:

| Option | Pros | Cons |
| ----- | ----- | ----- |
| **Current protoc \+ grpcio** | Well-maintained by Google; full sync \+ async support; proven performance and keep-alive control | Verbose low-level API; challenging to maintain and read; lacks Pythonic abstractions |
| **BetterProto1** | Generates Pythonic classes; easier message construction | Unmaintained; uses grpclib instead of grpcio; no built-in sync support |
| **BetterProto2 (future)** | Promises both sync (grpcio) and async; more idiomatic Python interface | Actively developing & unstable; async still on grpclib; not ready for production |

**Recommendation:** Continue using current protoc \+ grpcio for v1.0, deferring BetterProto v2 until it reaches stability.

#### **2\. Low-Level API Exposure**

We must decide whether the Low-Level API (thin wrappers around the autogen code) should remain purely internal or be exposed publicly alongside the high-level client.

| Approach | Pros | Cons |
| :---- | :---- | :---- |
| **Internal-only** | Simplifies public API surface; encourages high-level abstraction; freedom to refactor | Advanced users must install a second package (if we go that route) or no access to autogen code |
| **Public alongside high-level** | Continued availability of low-level autogen code to access any Sift API | Larger public surface to support, difficult to use autogen code |

**Decision:** Maintain current low-level autogen code. May be improved significantly in future with betterproto2.

### **Schedule**

Note: releases can be done incrementally and until final release, new high-level API will be subject to change

| Phase | Expected Milestones |
| :---- | :---- |
| 1 | Setup new folder structures (as applicable), create example low-level wrappers for working with 2-3 different Sift data types |
| 2 | Implement high-level APIs for the 2-3 Sift data types created in previous phase implementing common interaction methods |
| 3 | Design testing scheme (integration tests) |
| 4 | Prototype mkdocs deployment w/ basic examples, “alpha” release of example high-level API to solicit customer feedback |
| 5 | Implement data API (focus on export and file upload) |
| 6 | Flesh out remaining Sift data types with low-level wrappers and high-level API |
| 7 | Instrument library for metrics reporting |
| 8 | Integrate `sift-stream-python-bindings` with data API for streaming import |
| 9 | Create jupyter notebook examples and publish with docs. “Final” release or release candidate, add deprecation warnings to legacy services/implementations |
| 10 | Remove legacy services and interfaces and only maintain new high-level API as user facing code |

`Sift-stream-python-bindings` can be developed in parallel with high-level python client and only needs integration with high-level API when ready.

### **Integration & Deployment**

* Continuous integration through GitHub Actions.  
* SemVer for clear versioning.  
* Public PyPI publishing on release tags.

### **Open Questions**

| Question | Next Step |
| :---- | :---- |
| Continued support for yaml interface?  | Identify users, how this may fit into a larger core Sift feature? |

### **Decisions as part of RFC review**

| Decision | Comment |
| :---- | :---- |
| Maintain public facing autogen code | Feedback was to keep access available to advanced users who desire the low level API access |
| Keep supporting Python 3.8+ | While no identified users seem to be relying on \<Python 3.10, it was decided that we don’t want to open up the possibility of future customers having issues with uptake over Python versions |

