<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="_FB_SendSiftMessage" Id="{7623e9eb-5640-4421-9ec0-77d8fab14f49}" SpecialFunc="None">
    <Declaration><![CDATA[// Sends a message to Sift Proxy using the Sift Proxy Protocol and waits for a response.
FUNCTION_BLOCK _FB_SendSiftMessage
VAR_INPUT
	hSiftClient : REFERENCE TO T_SiftClient;
	stMsg : REFERENCE TO _ST_SiftMessage;
	bExecute : BOOL;
	bWaitForReply : BOOL := TRUE;
	tReplyTimeout : TIME := T#1S;
END_VAR
VAR_OUTPUT
	bBusy : BOOL;
	bError : BOOL;
	stResponse : _ST_SiftMessage;
	nErrId : UDINT;
END_VAR

VAR
	eState : (IDLE, SEND_MESSAGE, SEND_MESSAGE_WAIT, RECEIVE_REPLY_START_TIMER, RECEIVE_REPLY, RECEIVE_REPLY_WAIT, SUCCESS, FAILURE):= IDLE;
	aRawBuf : ARRAY[1..SiftClientParameters.MAX_PACKET_SIZE] OF BYTE; // For the BufferWriter. Used for sending/receiving.
	fbWriter : _FB_BufferWriter := (pRawBuf := ADR(aRawBuf), nSize := SIZEOF(aRawBuf));	
	aRecvBuf : ARRAY[1..SiftClientParameters.MAX_PACKET_SIZE] OF BYTE; // Used for immediate recv calls.
	responseTimer : TON; // Timer for how longer to wait for a response from sift_proxy.
	nBytesRead : UDINT; // Current offset into the recv message.
	nRecvSyncWord : UDINT;	
	nRecvCount : UDINT;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eState OF
	IDLE:
		IF bExecute THEN
			eState := SEND_MESSAGE;
		END_IF
		
	SEND_MESSAGE:
		bBusy := TRUE;
		bError := FALSE;
		
		// Verify MAX_PACKET_SIZE is a reasonable number
		IF SiftClientParameters.MAX_PACKET_SIZE <= GVL_SIFT.HEADER_LENGTH THEN
			nErrId := GVL_SIFT.BAD_PARAMETERS;
			eState := FAILURE;
			RETURN;
		END_IF
		
		// Sync word
		IF NOT fbWriter.Write(ADR(GVL_SIFT.SYNC_WORD), 4) THEN
			nErrId := GVL_SIFT.MEMCPY_ERROR;
			eState := FAILURE;
			RETURN;
		END_IF
		
		// Message type		
		IF NOT fbWriter.Write(ADR(stMsg.nType), 1) THEN
			nErrId := GVL_SIFT.MEMCPY_ERROR;
			eState := FAILURE;
			RETURN;
		END_IF
		
		// Message length
		IF NOT fbWriter.Write(ADR(stMsg.nLength), 4) THEN
			nErrId := GVL_SIFT.MEMCPY_ERROR;
			eState := FAILURE;
			RETURN;
		END_IF
			
		// Data.
		IF NOT fbWriter.Write(ADR(stMsg.aData), stMsg.nLength) THEN
			nErrId := GVL_SIFT.MEMCPY_ERROR;
			eState := FAILURE;
			RETURN;
		END_IF
		
		hSiftClient.fbSend(
			hSocket := hSiftClient.fbConnect.hSocket, 
			pSrc := ADR(aRawBuf),
			cbLen := stMsg.nLength + GVL_SIFT.HEADER_LENGTH,
			bExecute := TRUE,
		);
		fbWriter.SetOffset(0);	
		eState := SEND_MESSAGE_WAIT;

	SEND_MESSAGE_WAIT:
		bBusy := TRUE;
		bError := FALSE;
		hSiftClient.fbSend(bExecute := FALSE);
		
		IF hSiftClient.fbSend.bBusy THEN
			RETURN;
		ELSIF hSiftClient.fbSend.bError THEN
			nErrId := hSiftClient.fbSend.nErrId;
			eState := FAILURE;
			RETURN;
		END_IF
		
		IF bWaitForReply THEN
			eState := RECEIVE_REPLY_START_TIMER;
		ELSE
			eState := SUCCESS;
		END_IF
	
	RECEIVE_REPLY_START_TIMER:
		bBusy := TRUE;
		bError := FALSE;
		responseTimer(IN:=FALSE);
		responseTimer(IN:=TRUE, PT:=tReplyTimeout);
		eState := RECEIVE_REPLY;
		nBytesRead := 0;
		
	RECEIVE_REPLY:
		bBusy := TRUE;
		bError := FALSE;

		hSiftClient.fbReceive(
			hSocket := hSiftClient.fbConnect.hSocket,
			cbLen := SiftClientParameters.MAX_PACKET_SIZE,
			pDest := ADR(aRecvBuf),
			bExecute := TRUE,
		);
		eState := RECEIVE_REPLY_WAIT;
		
	RECEIVE_REPLY_WAIT:
		bBusy := TRUE;
		bError := FALSE;
		hSiftClient.fbReceive(bExecute := FALSE);
		responseTimer();
				
		IF hSiftClient.fbReceive.bBusy THEN
			RETURN;
		ELSIF hSiftClient.fbReceive.bError THEN
			IF responseTimer.Q THEN
				nErrId := hSiftClient.fbReceive.nErrId;
				eState := FAILURE;
			ELSE
				eState := RECEIVE_REPLY;
			END_IF
			RETURN;
		END_IF
		
		IF hSiftClient.fbReceive.nRecBytes = 0 THEN
			IF responseTimer.Q THEN
				eState := FAILURE;
				nErrId := GVL_SIFT.SIFT_PROXY_NO_RESPONSE;
			ELSE	
				eState := RECEIVE_REPLY;
			END_IF		
			RETURN;
		END_IF
			
		IF NOT fbWriter.Write(ADR(aRecvBuf), hSiftClient.fbReceive.nRecBytes) THEN
			nErrId := GVL_SIFT.MEMCPY_ERROR;
			eState := FAILURE;
			RETURN;
		END_IF
		
		// If we have a complete header.
		IF fbWriter.nCurOffset >= GVL_SIFT.HEADER_LENGTH THEN
			IF NOT SAFE_MEMCPY(ADR(nRecvSyncWord), SIZEOF(nRecvSyncWord), ADR(aRawBuf), 4) THEN
				nErrId := GVL_SIFT.MEMCPY_ERROR;
				eState := FAILURE;
				RETURN;
			END_IF
			IF nRecvSyncWord <> GVL_SIFT.SYNC_WORD THEN
				eState := FAILURE;
				nErrId := GVL_SIFT.SIFT_PROXY_INVALID_SYNC_WORD;;
				RETURN;
			END_IF
			
			stResponse.nType := aRawBuf[GVL_SIFT.MESSAGE_TYPE_INDEX+1];
			IF stResponse.nType <> GVL_SIFT.RESPONSE_MESSAGE_TYPE THEN
				eState := FAILURE;
				nErrId := GVL_SIFT.SIFT_PROXY_INVALID_RESPONSE;;
				RETURN;
			END_IF	
			
			IF NOT SAFE_MEMCPY(ADR(stResponse.nLength), SIZEOF(stResponse.nLength), ADR(aRawBuf[GVL_SIFT.MESSGE_LENGTH_INDEX+1]), 4) THEN
				nErrId := GVL_SIFT.MEMCPY_ERROR;
				eState := FAILURE;
				RETURN;
			END_IF

			// Verify that the size of this message isn't larger than our buffer.
			IF stResponse.nLength > SIZEOF(stResponse.aData) THEN
				eState := FAILURE;
				nErrId := GVL_SIFT.BUFFER_CAPACITY_REACHED;
				RETURN;
			END_IF
			
			// Check if we have the whole packet
			IF fbWriter.nCurOffset >= GVL_SIFT.HEADER_LENGTH + stResponse.nLength THEN
				IF NOT SAFE_MEMCPY(ADR(stResponse.aData), SIZEOF(stResponse.aData),
								   ADR(aRawBuf[GVL_SIFT.HEADER_LENGTH+1]), stResponse.nLength) THEN
					nErrId := GVL_SIFT.MEMCPY_ERROR;
					eState := FAILURE;
					RETURN;
				END_IF
				
			ELSE // Incomplete packet.
				eState := RECEIVE_REPLY;
				RETURN;
			END_IF

		ELSE // Incomplete header.
			eState := RECEIVE_REPLY;
			RETURN;
		END_IF
		
		eState := SUCCESS;
		
	SUCCESS:
		bBusy := FALSE;
		bError := FALSE;
		eState := IDLE;
		
	FAILURE:
		bBusy := FALSE;
		bError := TRUE;
		eState := IDLE;
END_CASE


]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>