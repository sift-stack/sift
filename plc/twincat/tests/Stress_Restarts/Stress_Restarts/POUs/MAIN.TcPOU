<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{7ccbb6f8-c213-4a05-8b24-7eb24159ab86}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	/// Integration test that stress tests restarting Sift Client.
	/// This is needed until we properly mock TCP connections in the Sift Client.
	/// Instrucstions to run:
	/// 1. Fill in sGrpcUri and sApiKey
	///     See https://docs.siftstack.com/docs
	///     For obtaining gRPC and API key information.
	/// 2. Make sure install_sift_proxy.bat script has been run to install sift_proxy.
	/// 3. Run!
	sGrpcUri : STRING(255) := '';
	sApiKey : STRING(255) := '';
	sLogDir : STRING(255) := '';
		
	aJsonBuffer : ARRAY[1..65535] OF BYTE; // Buffer used to create JSON messages. Increase this if you get JSON_CAPACITY_REACHED errors.
	
	// Run information.
	sRunName : STRING(255) := 'TwinCat3 Stress Restart Test';
	sRunDescription : STRING(255) := 'Stress test restarting Sift Client.';

	// Flows and Channels created here should all be pointers and initialized with CreateFlowConfig and CreateChannelConfig
	pFlow1 : POINTER TO ST_FlowConfig;
	pIntChannel1 : POINTER TO ST_ChannelConfig;
	pTestCountChannel : POINTER TO ST_ChannelConfig;
	pEnumChannel2 : POINTER TO ST_ChannelConfig;
	aChannel2Enums : ARRAY[1..SiftClientParameters.MAX_NUM_ENUMS_PER_CHANNEL] OF ST_EnumType := [
		(nKey:=0, sName:='enum1'),
		(nKey:=1, sName:='enum2'),
		(nKey:=2, sName:='enum3'),
		(nKey:=3, sName:='enum4')
	];
	
	pFlow2 : POINTER TO ST_FlowConfig;
	pStringChannel3 : POINTER TO ST_ChannelConfig;
	pBufUtilChannel : POINTER TO ST_ChannelConfig;
	
	// Example values that would come from sensors or other parts of the PLC application.
	nData1 : DINT := 0;
	nData2 : UDINT := 0;
	sData3 : STRING(255) := 'This is a string value from the PLC task.';

	// Sift Client used for all services.
	fbSiftClient : FB_SiftClient;
	
	// The Ingestion Config. See https://docs.siftstack.com/docs/glossary#ingestion-config
 	// Ingestion Config service used to register the ingestion config.
	fbIngestionConfig : FB_IngestionConfigService;
	
	// Run service used to create new Runs.
	fbRun : FB_RunService;
	
	// Ingest service used to stream data.
	fbIngest : FB_IngestService;

	eSiftState : (
		INIT_SIFT_CLIENT,		// Begin initializing the Sift Client.
		INIT_SIFT_CLIENT_WAIT,	// Complete initializing the Sift Client.
		SUBMIT_CONFIG,			// Create and submit the ingestion config.
		SUBMIT_CONFIG_WAIT,		// Wait for the call to finish.
		SUBMIT_RUN,				// Create and submit the Run.
		SUBMIT_RUN_WAIT,		// Wait for the call to finish.
		INGEST_DATA,			// Main state for ingesting data.
		STOP_INGEST_WAIT,       // Wait for data in transit to finish sending.
		STOP,					// Close and stop the Sift Client.
		STOP_WAIT, 			    // Wait for the Sift Client to clean up.
		ERROR,					// An error has occurred.
		IDLE_STOP,				// Idle state after stopping.
		TEST_SUCCESS,
	) := INIT_SIFT_CLIENT;
	
	currentTestCount : UDINT;
	currentTestDuration : TON;
	totalTestCount : UDINT := 100;
	testDuration : TIME := T#5S;	
	bInitialized : BOOL;
	bStop : BOOL; 			// Set this to True to close the Sift Client and stop the program.
	bRestart : BOOL; 		// Set this to True after stopping to restart ingestion.
	bConfigError : BOOL;	// True if there is an error creating or submitting the ingestion config.
	bWriteOk : BOOL; 		// True if there is an error writing data.
	nErrId : UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eSiftState OF
	INIT_SIFT_CLIENT:
		bStop := FALSE;
		bRestart := FALSE;
		fbSiftClient(sGrpcUri := sGrpcUri, 
					 sApiKey := sApiKey,
					 sLogDir := sLogDir,
					 pJsonBuffer := ADR(aJsonBuffer),
					 pJbLength := SIZEOF(aJsonBuffer),
					 bExecute := TRUE);
		eSiftState := INIT_SIFT_CLIENT_WAIT;

	INIT_SIFT_CLIENT_WAIT:
		fbSiftClient(bExecute := FALSE);
		IF fbSiftClient.bBusy THEN
			RETURN;
		ELSIF fbSiftClient.bError THEN
			nErrId := fbSiftClient.nErrId;
			eSiftState := ERROR;
			RETURN;
		END_IF
			
		eSiftState := SUBMIT_CONFIG;
	
	SUBMIT_CONFIG:
	    // Always reset the ingestion config in this state since it can be called repeatedly.
	    fbIngestionConfig.Reset();
		
		pFlow1 := fbIngestionConfig.CreateFlowConfig(sName := 'flow_1');
		IF pFlow1 = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
		pIntChannel1 := fbIngestionConfig.CreateChannelConfig(pFlowConfig := pFlow1, 
															  sName:='plc.int_channel1', 
															  eDataType:=E_ChannelDataType.Int32, 
															  sDescription:='An integer channel', 
															  sUnit:='count');
		IF pIntChannel1 = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
		
		pTestCountChannel := fbIngestionConfig.CreateChannelConfig(pFlowConfig := pFlow1, 
															  sName:='test_count', 
															  eDataType:=E_ChannelDataType.UInt32, 
															  sDescription:='Current test iteration', 
															  sUnit:='');
		IF pTestCountChannel = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
		
		pEnumChannel2 := fbIngestionConfig.CreateChannelConfig(pFlowConfig := pFlow1, 
																sName:='plc.enum_channel2', 
																eDataType:=E_ChannelDataType.Enum, 
																sDescription:='An enum channel', 
																sUnit:='state');
		IF pEnumChannel2 = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
																
		IF NOT fbIngestionConfig.InitEnumTypes(pChannelConfig := pEnumChannel2, aEnumTypes:=aChannel2Enums) THEN 
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
										   
		pFlow2 := fbIngestionConfig.CreateFlowConfig(sName := 'flow_2');
		IF pFlow2 = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
		
		pStringChannel3 := fbIngestionConfig.CreateChannelConfig(pFlowConfig := pFlow2, 
													 			 sName:='plc.string_channel3', 
																 eDataType:=E_ChannelDataType.String_, 
																 sDescription:='An integer channel', 
																 sUnit:='text');
		IF pStringChannel3 = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF
		
		pBufUtilChannel := fbIngestionConfig.CreateChannelConfig(pFlowConfig := pFlow2,  
												    			 sName:='buffer_utilitation', 
																 eDataType:=E_ChannelDataType.Double, 
																 sDescription:='fbIngest buffer utilization', 
																 sUnit:='');
		IF pBufUtilChannel = 0 THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.INVALID_INGESTION_CONFIG;
			RETURN;
		END_IF

		IF NOT fbIngestionConfig.Validate() THEN
			eSiftState := ERROR;
			nErrId := GVL_SIFT.BUFFER_CAPACITY_REACHED;
			RETURN;
		END_IF
		
		fbIngestionConfig(sAssetName := 'Test-PLC-Example', 
						  hSiftClient:=fbSiftClient.hSiftClient,
					      bExecute:=TRUE);
		eSiftState := SUBMIT_CONFIG_WAIT;

	SUBMIT_CONFIG_WAIT:
		fbIngestionConfig(bExecute:=FALSE);
		IF fbIngestionConfig.bBusy THEN
			RETURN;
		ELSIF fbIngestionConfig.bError THEN
			nErrId := fbIngestionConfig.nErrId;
			eSiftState := ERROR;
			RETURN;
		END_IF

		// Start timer for next test.
		currentTestDuration(IN:=FALSE);
		currentTestDuration(IN:=TRUE, PT:=testDuration);
			
		// Skip creating a new run for additional tests.
		IF bInitialized THEN
			eSiftState := INGEST_DATA;	
		ELSE
    		eSiftState := SUBMIT_RUN;
		END_IF

	SUBMIT_RUN:
		fbRun(bExecute := TRUE, 
			  hSiftClient := fbSiftClient.hSiftClient,
			  sName:=sRunName, 
			  sDescription := sRunDescription);
		eSiftState := SUBMIT_RUN_WAIT;

	SUBMIT_RUN_WAIT:
		fbRun(bExecute := FALSE);
		IF fbRun.bBusy THEN
			RETURN;
		ELSIF fbRun.bError THEN
			nErrId := fbRun.nErrId;
			eSiftState := ERROR;
			RETURN;
		END_IF
		eSiftState := INGEST_DATA;
		bInitialized := TRUE;

	// Ingest data for the configured duration.		
	INGEST_DATA:
		fbIngest(hSiftClient := fbSiftClient.hSiftClient, sRunId:=fbRun.sId);
		currentTestDuration();
				 
		// Verify there are no ingestion errors.
		IF fbIngest.bError THEN
			nErrId := fbIngest.nErrId;
			eSiftState := ERROR;
		END_IF
				 
		// Update values as needed throughout the code. 
		nData1 := nData1 + 1;
		IF nData1 MOD 1000 = 0 THEN
			nData2 := (nData2 + 1) MOD 4;
		END_IF
		
		// Ideally you should check the result between each call,
		// but we only check once to simplify the example.
		bWriteOk := SetChannelValue(pIntChannel1, nData1);
		bWriteOk := bWriteOk OR SetChannelValue(pEnumChannel2, nData2);
		bWriteOk := bWriteOk OR SetChannelValue(pStringChannel3, sData3);
		bWriteOk := bWriteOk OR SetChannelValue(pBufUtilChannel, fbIngest.fBufferUtilization);
		bWriteOk := bWriteOk OR SetChannelValue(pTestCountChannel, currentTestCount);
		IF NOT bWriteOk THEN
			eSiftState := ERROR;
			RETURN;
		END_IF
		
		// Call WriteData at the desired frequency for each flow.
		bWriteOk := fbIngest.WriteData(pFlow1, GetCurrentTime());
		IF NOT bWriteOk THEN
			eSiftState := ERROR;
			RETURN;
		END_IF
		
		bWriteOk := fbIngest.WriteData(pFlow2, GetCurrentTime());
		IF NOT bWriteOk THEN
			eSiftState := ERROR;
			RETURN;
		END_IF
		
		IF currentTestDuration.Q THEN
			eSiftState := STOP_INGEST_WAIT;
			RETURN;
		END_IF
		
	STOP_INGEST_WAIT:
	    fbIngest();
	    IF fbIngest.bBusy THEN
			RETURN;
		END_IF
		eSiftState := STOP;
		
	STOP:
		fbSiftClient(bStop := TRUE);
		eSiftState := STOP_WAIT;
	
	STOP_WAIT:
    	fbSiftClient(bStop := FALSE);
		IF fbSiftClient.bBusy THEN
			RETURN;
		END_IF
		eSiftState := IDLE_STOP;
		
	IDLE_STOP:
		fbSiftClient(bStop := FALSE);
		currentTestCount := currentTestCount + 1;
	    IF currentTestCount < totalTestCount THEN
			eSiftState := INIT_SIFT_CLIENT;
		ELSE
			eSiftState := TEST_SUCCESS;
		END_IF
		
	ERROR:
	    IF bRestart THEN
			eSiftState := INIT_SIFT_CLIENT;
		END_IF
END_CASE
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>