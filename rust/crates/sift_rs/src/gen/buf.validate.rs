// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(string, optional, tag="1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub expression: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageRules {
    #[prost(message, repeated, tag="3")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
    #[prost(message, repeated, tag="4")]
    pub oneof: ::prost::alloc::vec::Vec<MessageOneofRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageOneofRule {
    #[prost(string, repeated, tag="1")]
    pub fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub required: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OneofRules {
    #[prost(bool, optional, tag="1")]
    pub required: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldRules {
    #[prost(message, repeated, tag="23")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
    #[prost(bool, optional, tag="25")]
    pub required: ::core::option::Option<bool>,
    #[prost(enumeration="Ignore", optional, tag="27")]
    pub ignore: ::core::option::Option<i32>,
    #[prost(oneof="field_rules::Type", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22")]
    pub r#type: ::core::option::Option<field_rules::Type>,
}
/// Nested message and enum types in `FieldRules`.
pub mod field_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="1")]
        Float(super::FloatRules),
        #[prost(message, tag="2")]
        Double(super::DoubleRules),
        #[prost(message, tag="3")]
        Int32(super::Int32Rules),
        #[prost(message, tag="4")]
        Int64(super::Int64Rules),
        #[prost(message, tag="5")]
        Uint32(super::UInt32Rules),
        #[prost(message, tag="6")]
        Uint64(super::UInt64Rules),
        #[prost(message, tag="7")]
        Sint32(super::SInt32Rules),
        #[prost(message, tag="8")]
        Sint64(super::SInt64Rules),
        #[prost(message, tag="9")]
        Fixed32(super::Fixed32Rules),
        #[prost(message, tag="10")]
        Fixed64(super::Fixed64Rules),
        #[prost(message, tag="11")]
        Sfixed32(super::SFixed32Rules),
        #[prost(message, tag="12")]
        Sfixed64(super::SFixed64Rules),
        #[prost(message, tag="13")]
        Bool(super::BoolRules),
        #[prost(message, tag="14")]
        String(super::StringRules),
        #[prost(message, tag="15")]
        Bytes(super::BytesRules),
        #[prost(message, tag="16")]
        Enum(super::EnumRules),
        #[prost(message, tag="18")]
        Repeated(::prost::alloc::boxed::Box<super::RepeatedRules>),
        #[prost(message, tag="19")]
        Map(::prost::alloc::boxed::Box<super::MapRules>),
        #[prost(message, tag="20")]
        Any(super::AnyRules),
        #[prost(message, tag="21")]
        Duration(super::DurationRules),
        #[prost(message, tag="22")]
        Timestamp(super::TimestampRules),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredefinedRules {
    #[prost(message, repeated, tag="1")]
    pub cel: ::prost::alloc::vec::Vec<Rule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatRules {
    #[prost(float, optional, tag="1")]
    pub r#const: ::core::option::Option<f32>,
    #[prost(float, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<f32>,
    #[prost(bool, optional, tag="8")]
    pub finite: ::core::option::Option<bool>,
    #[prost(float, repeated, packed="false", tag="9")]
    pub example: ::prost::alloc::vec::Vec<f32>,
    #[prost(oneof="float_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<float_rules::LessThan>,
    #[prost(oneof="float_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<float_rules::GreaterThan>,
}
/// Nested message and enum types in `FloatRules`.
pub mod float_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(float, tag="2")]
        Lt(f32),
        #[prost(float, tag="3")]
        Lte(f32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(float, tag="4")]
        Gt(f32),
        #[prost(float, tag="5")]
        Gte(f32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleRules {
    #[prost(double, optional, tag="1")]
    pub r#const: ::core::option::Option<f64>,
    #[prost(double, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<f64>,
    #[prost(double, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<f64>,
    #[prost(bool, optional, tag="8")]
    pub finite: ::core::option::Option<bool>,
    #[prost(double, repeated, packed="false", tag="9")]
    pub example: ::prost::alloc::vec::Vec<f64>,
    #[prost(oneof="double_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<double_rules::LessThan>,
    #[prost(oneof="double_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<double_rules::GreaterThan>,
}
/// Nested message and enum types in `DoubleRules`.
pub mod double_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(double, tag="2")]
        Lt(f64),
        #[prost(double, tag="3")]
        Lte(f64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(double, tag="4")]
        Gt(f64),
        #[prost(double, tag="5")]
        Gte(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int32Rules {
    #[prost(int32, optional, tag="1")]
    pub r#const: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof="int32_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<int32_rules::LessThan>,
    #[prost(oneof="int32_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<int32_rules::GreaterThan>,
}
/// Nested message and enum types in `Int32Rules`.
pub mod int32_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(int32, tag="2")]
        Lt(i32),
        #[prost(int32, tag="3")]
        Lte(i32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(int32, tag="4")]
        Gt(i32),
        #[prost(int32, tag="5")]
        Gte(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int64Rules {
    #[prost(int64, optional, tag="1")]
    pub r#const: ::core::option::Option<i64>,
    #[prost(int64, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, repeated, packed="false", tag="9")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof="int64_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<int64_rules::LessThan>,
    #[prost(oneof="int64_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<int64_rules::GreaterThan>,
}
/// Nested message and enum types in `Int64Rules`.
pub mod int64_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(int64, tag="2")]
        Lt(i64),
        #[prost(int64, tag="3")]
        Lte(i64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(int64, tag="4")]
        Gt(i64),
        #[prost(int64, tag="5")]
        Gte(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UInt32Rules {
    #[prost(uint32, optional, tag="1")]
    pub r#const: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<u32>,
    #[prost(oneof="u_int32_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<u_int32_rules::LessThan>,
    #[prost(oneof="u_int32_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<u_int32_rules::GreaterThan>,
}
/// Nested message and enum types in `UInt32Rules`.
pub mod u_int32_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(uint32, tag="2")]
        Lt(u32),
        #[prost(uint32, tag="3")]
        Lte(u32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(uint32, tag="4")]
        Gt(u32),
        #[prost(uint32, tag="5")]
        Gte(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UInt64Rules {
    #[prost(uint64, optional, tag="1")]
    pub r#const: ::core::option::Option<u64>,
    #[prost(uint64, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<u64>,
    #[prost(oneof="u_int64_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<u_int64_rules::LessThan>,
    #[prost(oneof="u_int64_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<u_int64_rules::GreaterThan>,
}
/// Nested message and enum types in `UInt64Rules`.
pub mod u_int64_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(uint64, tag="2")]
        Lt(u64),
        #[prost(uint64, tag="3")]
        Lte(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(uint64, tag="4")]
        Gt(u64),
        #[prost(uint64, tag="5")]
        Gte(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SInt32Rules {
    #[prost(sint32, optional, tag="1")]
    pub r#const: ::core::option::Option<i32>,
    #[prost(sint32, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    #[prost(sint32, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    #[prost(sint32, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof="s_int32_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<s_int32_rules::LessThan>,
    #[prost(oneof="s_int32_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<s_int32_rules::GreaterThan>,
}
/// Nested message and enum types in `SInt32Rules`.
pub mod s_int32_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(sint32, tag="2")]
        Lt(i32),
        #[prost(sint32, tag="3")]
        Lte(i32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(sint32, tag="4")]
        Gt(i32),
        #[prost(sint32, tag="5")]
        Gte(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SInt64Rules {
    #[prost(sint64, optional, tag="1")]
    pub r#const: ::core::option::Option<i64>,
    #[prost(sint64, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    #[prost(sint64, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    #[prost(sint64, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof="s_int64_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<s_int64_rules::LessThan>,
    #[prost(oneof="s_int64_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<s_int64_rules::GreaterThan>,
}
/// Nested message and enum types in `SInt64Rules`.
pub mod s_int64_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(sint64, tag="2")]
        Lt(i64),
        #[prost(sint64, tag="3")]
        Lte(i64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(sint64, tag="4")]
        Gt(i64),
        #[prost(sint64, tag="5")]
        Gte(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fixed32Rules {
    #[prost(fixed32, optional, tag="1")]
    pub r#const: ::core::option::Option<u32>,
    #[prost(fixed32, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed32, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed32, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<u32>,
    #[prost(oneof="fixed32_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<fixed32_rules::LessThan>,
    #[prost(oneof="fixed32_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<fixed32_rules::GreaterThan>,
}
/// Nested message and enum types in `Fixed32Rules`.
pub mod fixed32_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(fixed32, tag="2")]
        Lt(u32),
        #[prost(fixed32, tag="3")]
        Lte(u32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(fixed32, tag="4")]
        Gt(u32),
        #[prost(fixed32, tag="5")]
        Gte(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fixed64Rules {
    #[prost(fixed64, optional, tag="1")]
    pub r#const: ::core::option::Option<u64>,
    #[prost(fixed64, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<u64>,
    #[prost(fixed64, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<u64>,
    #[prost(fixed64, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<u64>,
    #[prost(oneof="fixed64_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<fixed64_rules::LessThan>,
    #[prost(oneof="fixed64_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<fixed64_rules::GreaterThan>,
}
/// Nested message and enum types in `Fixed64Rules`.
pub mod fixed64_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(fixed64, tag="2")]
        Lt(u64),
        #[prost(fixed64, tag="3")]
        Lte(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(fixed64, tag="4")]
        Gt(u64),
        #[prost(fixed64, tag="5")]
        Gte(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SFixed32Rules {
    #[prost(sfixed32, optional, tag="1")]
    pub r#const: ::core::option::Option<i32>,
    #[prost(sfixed32, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    #[prost(sfixed32, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    #[prost(sfixed32, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof="s_fixed32_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<s_fixed32_rules::LessThan>,
    #[prost(oneof="s_fixed32_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<s_fixed32_rules::GreaterThan>,
}
/// Nested message and enum types in `SFixed32Rules`.
pub mod s_fixed32_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(sfixed32, tag="2")]
        Lt(i32),
        #[prost(sfixed32, tag="3")]
        Lte(i32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(sfixed32, tag="4")]
        Gt(i32),
        #[prost(sfixed32, tag="5")]
        Gte(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SFixed64Rules {
    #[prost(sfixed64, optional, tag="1")]
    pub r#const: ::core::option::Option<i64>,
    #[prost(sfixed64, repeated, packed="false", tag="6")]
    pub r#in: ::prost::alloc::vec::Vec<i64>,
    #[prost(sfixed64, repeated, packed="false", tag="7")]
    pub not_in: ::prost::alloc::vec::Vec<i64>,
    #[prost(sfixed64, repeated, packed="false", tag="8")]
    pub example: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof="s_fixed64_rules::LessThan", tags="2, 3")]
    pub less_than: ::core::option::Option<s_fixed64_rules::LessThan>,
    #[prost(oneof="s_fixed64_rules::GreaterThan", tags="4, 5")]
    pub greater_than: ::core::option::Option<s_fixed64_rules::GreaterThan>,
}
/// Nested message and enum types in `SFixed64Rules`.
pub mod s_fixed64_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(sfixed64, tag="2")]
        Lt(i64),
        #[prost(sfixed64, tag="3")]
        Lte(i64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(sfixed64, tag="4")]
        Gt(i64),
        #[prost(sfixed64, tag="5")]
        Gte(i64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolRules {
    #[prost(bool, optional, tag="1")]
    pub r#const: ::core::option::Option<bool>,
    #[prost(bool, repeated, packed="false", tag="2")]
    pub example: ::prost::alloc::vec::Vec<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringRules {
    #[prost(string, optional, tag="1")]
    pub r#const: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="19")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub min_len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub max_len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="20")]
    pub len_bytes: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="4")]
    pub min_bytes: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="5")]
    pub max_bytes: ::core::option::Option<u64>,
    #[prost(string, optional, tag="6")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="7")]
    pub prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="8")]
    pub suffix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="9")]
    pub contains: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="23")]
    pub not_contains: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="10")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="11")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="25")]
    pub strict: ::core::option::Option<bool>,
    #[prost(string, repeated, tag="34")]
    pub example: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof="string_rules::WellKnown", tags="12, 13, 14, 15, 16, 17, 18, 21, 22, 33, 26, 27, 28, 29, 30, 31, 32, 24")]
    pub well_known: ::core::option::Option<string_rules::WellKnown>,
}
/// Nested message and enum types in `StringRules`.
pub mod string_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum WellKnown {
        #[prost(bool, tag="12")]
        Email(bool),
        #[prost(bool, tag="13")]
        Hostname(bool),
        #[prost(bool, tag="14")]
        Ip(bool),
        #[prost(bool, tag="15")]
        Ipv4(bool),
        #[prost(bool, tag="16")]
        Ipv6(bool),
        #[prost(bool, tag="17")]
        Uri(bool),
        #[prost(bool, tag="18")]
        UriRef(bool),
        #[prost(bool, tag="21")]
        Address(bool),
        #[prost(bool, tag="22")]
        Uuid(bool),
        #[prost(bool, tag="33")]
        Tuuid(bool),
        #[prost(bool, tag="26")]
        IpWithPrefixlen(bool),
        #[prost(bool, tag="27")]
        Ipv4WithPrefixlen(bool),
        #[prost(bool, tag="28")]
        Ipv6WithPrefixlen(bool),
        #[prost(bool, tag="29")]
        IpPrefix(bool),
        #[prost(bool, tag="30")]
        Ipv4Prefix(bool),
        #[prost(bool, tag="31")]
        Ipv6Prefix(bool),
        #[prost(bool, tag="32")]
        HostAndPort(bool),
        #[prost(enumeration="super::KnownRegex", tag="24")]
        WellKnownRegex(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BytesRules {
    #[prost(bytes="vec", optional, tag="1")]
    pub r#const: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag="13")]
    pub len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub min_len: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub max_len: ::core::option::Option<u64>,
    #[prost(string, optional, tag="4")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="5")]
    pub prefix: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="6")]
    pub suffix: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", optional, tag="7")]
    pub contains: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", repeated, tag="8")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", repeated, tag="9")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", repeated, tag="14")]
    pub example: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(oneof="bytes_rules::WellKnown", tags="10, 11, 12")]
    pub well_known: ::core::option::Option<bytes_rules::WellKnown>,
}
/// Nested message and enum types in `BytesRules`.
pub mod bytes_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum WellKnown {
        #[prost(bool, tag="10")]
        Ip(bool),
        #[prost(bool, tag="11")]
        Ipv4(bool),
        #[prost(bool, tag="12")]
        Ipv6(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumRules {
    #[prost(int32, optional, tag="1")]
    pub r#const: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="2")]
    pub defined_only: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed="false", tag="3")]
    pub r#in: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="4")]
    pub not_in: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="5")]
    pub example: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepeatedRules {
    #[prost(uint64, optional, tag="1")]
    pub min_items: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub max_items: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="3")]
    pub unique: ::core::option::Option<bool>,
    #[prost(message, optional, boxed, tag="4")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapRules {
    #[prost(uint64, optional, tag="1")]
    pub min_pairs: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub max_pairs: ::core::option::Option<u64>,
    #[prost(message, optional, boxed, tag="4")]
    pub keys: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
    #[prost(message, optional, boxed, tag="5")]
    pub values: ::core::option::Option<::prost::alloc::boxed::Box<FieldRules>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnyRules {
    #[prost(string, repeated, tag="2")]
    pub r#in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub not_in: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DurationRules {
    #[prost(message, optional, tag="2")]
    pub r#const: ::core::option::Option<::pbjson_types::Duration>,
    #[prost(message, repeated, tag="7")]
    pub r#in: ::prost::alloc::vec::Vec<::pbjson_types::Duration>,
    #[prost(message, repeated, tag="8")]
    pub not_in: ::prost::alloc::vec::Vec<::pbjson_types::Duration>,
    #[prost(message, repeated, tag="9")]
    pub example: ::prost::alloc::vec::Vec<::pbjson_types::Duration>,
    #[prost(oneof="duration_rules::LessThan", tags="3, 4")]
    pub less_than: ::core::option::Option<duration_rules::LessThan>,
    #[prost(oneof="duration_rules::GreaterThan", tags="5, 6")]
    pub greater_than: ::core::option::Option<duration_rules::GreaterThan>,
}
/// Nested message and enum types in `DurationRules`.
pub mod duration_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(message, tag="3")]
        Lt(::pbjson_types::Duration),
        #[prost(message, tag="4")]
        Lte(::pbjson_types::Duration),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(message, tag="5")]
        Gt(::pbjson_types::Duration),
        #[prost(message, tag="6")]
        Gte(::pbjson_types::Duration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampRules {
    #[prost(message, optional, tag="2")]
    pub r#const: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag="9")]
    pub within: ::core::option::Option<::pbjson_types::Duration>,
    #[prost(message, repeated, tag="10")]
    pub example: ::prost::alloc::vec::Vec<::pbjson_types::Timestamp>,
    #[prost(oneof="timestamp_rules::LessThan", tags="3, 4, 7")]
    pub less_than: ::core::option::Option<timestamp_rules::LessThan>,
    #[prost(oneof="timestamp_rules::GreaterThan", tags="5, 6, 8")]
    pub greater_than: ::core::option::Option<timestamp_rules::GreaterThan>,
}
/// Nested message and enum types in `TimestampRules`.
pub mod timestamp_rules {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LessThan {
        #[prost(message, tag="3")]
        Lt(::pbjson_types::Timestamp),
        #[prost(message, tag="4")]
        Lte(::pbjson_types::Timestamp),
        #[prost(bool, tag="7")]
        LtNow(bool),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GreaterThan {
        #[prost(message, tag="5")]
        Gt(::pbjson_types::Timestamp),
        #[prost(message, tag="6")]
        Gte(::pbjson_types::Timestamp),
        #[prost(bool, tag="8")]
        GtNow(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Violations {
    #[prost(message, repeated, tag="1")]
    pub violations: ::prost::alloc::vec::Vec<Violation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Violation {
    #[prost(message, optional, tag="5")]
    pub field: ::core::option::Option<FieldPath>,
    #[prost(message, optional, tag="6")]
    pub rule: ::core::option::Option<FieldPath>,
    #[prost(string, optional, tag="2")]
    pub rule_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="4")]
    pub for_key: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldPath {
    #[prost(message, repeated, tag="1")]
    pub elements: ::prost::alloc::vec::Vec<FieldPathElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldPathElement {
    #[prost(int32, optional, tag="1")]
    pub field_number: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub field_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="::pbjson_types::field_descriptor_proto::Type", optional, tag="3")]
    pub field_type: ::core::option::Option<i32>,
    #[prost(enumeration="::pbjson_types::field_descriptor_proto::Type", optional, tag="4")]
    pub key_type: ::core::option::Option<i32>,
    #[prost(enumeration="::pbjson_types::field_descriptor_proto::Type", optional, tag="5")]
    pub value_type: ::core::option::Option<i32>,
    #[prost(oneof="field_path_element::Subscript", tags="6, 7, 8, 9, 10")]
    pub subscript: ::core::option::Option<field_path_element::Subscript>,
}
/// Nested message and enum types in `FieldPathElement`.
pub mod field_path_element {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Subscript {
        #[prost(uint64, tag="6")]
        Index(u64),
        #[prost(bool, tag="7")]
        BoolKey(bool),
        #[prost(int64, tag="8")]
        IntKey(i64),
        #[prost(uint64, tag="9")]
        UintKey(u64),
        #[prost(string, tag="10")]
        StringKey(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Ignore {
    Unspecified = 0,
    IfZeroValue = 1,
    Always = 3,
}
impl Ignore {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Ignore::Unspecified => "IGNORE_UNSPECIFIED",
            Ignore::IfZeroValue => "IGNORE_IF_ZERO_VALUE",
            Ignore::Always => "IGNORE_ALWAYS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IGNORE_UNSPECIFIED" => Some(Self::Unspecified),
            "IGNORE_IF_ZERO_VALUE" => Some(Self::IfZeroValue),
            "IGNORE_ALWAYS" => Some(Self::Always),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KnownRegex {
    Unspecified = 0,
    HttpHeaderName = 1,
    HttpHeaderValue = 2,
}
impl KnownRegex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KnownRegex::Unspecified => "KNOWN_REGEX_UNSPECIFIED",
            KnownRegex::HttpHeaderName => "KNOWN_REGEX_HTTP_HEADER_NAME",
            KnownRegex::HttpHeaderValue => "KNOWN_REGEX_HTTP_HEADER_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KNOWN_REGEX_UNSPECIFIED" => Some(Self::Unspecified),
            "KNOWN_REGEX_HTTP_HEADER_NAME" => Some(Self::HttpHeaderName),
            "KNOWN_REGEX_HTTP_HEADER_VALUE" => Some(Self::HttpHeaderValue),
            _ => None,
        }
    }
}
include!("buf.validate.serde.rs");
// @@protoc_insertion_point(module)