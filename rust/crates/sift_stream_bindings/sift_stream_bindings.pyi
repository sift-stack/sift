# This file is automatically generated by pyo3_stub_gen

__all__ = [
    "BackupMetricsSnapshotPy",
    "ChannelBitFieldElementPy",
    "ChannelConfigPy",
    "ChannelDataTypePy",
    "ChannelEnumPy",
    "ChannelEnumTypePy",
    "ChannelIndexPy",
    "ChannelValuePy",
    "ChannelValueTypePy",
    "CheckpointMetricsSnapshotPy",
    "DiskBackupPolicyPy",
    "DurationPy",
    "FlowBuilderPy",
    "FlowConfigPy",
    "FlowDescriptorBuilderPy",
    "FlowDescriptorPy",
    "FlowPy",
    "IngestWithConfigDataChannelValuePy",
    "IngestWithConfigDataStreamRequestPy",
    "IngestWithConfigDataStreamRequestWrapperPy",
    "IngestionConfigFormPy",
    "MetadataPy",
    "MetadataValuePy",
    "RecoveryStrategyPy",
    "RetryPolicyPy",
    "RollingFilePolicyPy",
    "RunFormPy",
    "RunSelectorPy",
    "SiftStreamBuilderPy",
    "SiftStreamMetricsSnapshotPy",
    "SiftStreamPy",
    "TimeValuePy",
    "ValuePy",
]

import builtins
import typing
from enum import Enum

@typing.final
class BackupMetricsSnapshotPy:
    cur_checkpoint_file_count: builtins.int
    cur_checkpoint_cur_file_size: builtins.int
    cur_checkpoint_bytes: builtins.int
    cur_checkpoint_messages: builtins.int
    total_file_count: builtins.int
    total_bytes: builtins.int
    total_messages: builtins.int
    committed_message_id: builtins.int
    queued_checkpoints: builtins.int
    queued_file_ctxs: builtins.int
    files_pending_ingestion: builtins.int
    files_ingested: builtins.int
    cur_ingest_retries: builtins.int

@typing.final
class ChannelBitFieldElementPy:
    name: builtins.str
    index: builtins.int
    bit_count: builtins.int
    def __new__(cls, name:builtins.str, index:builtins.int, bit_count:builtins.int) -> ChannelBitFieldElementPy: ...

@typing.final
class ChannelConfigPy:
    name: builtins.str
    unit: builtins.str
    description: builtins.str
    data_type: ChannelDataTypePy
    enum_types: builtins.list[ChannelEnumTypePy]
    bit_field_elements: builtins.list[ChannelBitFieldElementPy]
    def __new__(cls, name:builtins.str, unit:builtins.str, description:builtins.str, data_type:ChannelDataTypePy, enum_types:typing.Sequence[ChannelEnumTypePy], bit_field_elements:typing.Sequence[ChannelBitFieldElementPy]) -> ChannelConfigPy: ...

@typing.final
class ChannelEnumPy:
    def __new__(cls, val:builtins.int) -> ChannelEnumPy: ...

@typing.final
class ChannelEnumTypePy:
    name: builtins.str
    key: builtins.int
    def __new__(cls, name:builtins.str, key:builtins.int) -> ChannelEnumTypePy: ...

@typing.final
class ChannelIndexPy:
    ...

@typing.final
class ChannelValuePy:
    name: builtins.str
    value: ValuePy
    def __new__(cls, name:builtins.str, value:ValuePy) -> ChannelValuePy: ...

@typing.final
class ChannelValueTypePy:
    @staticmethod
    def bool(value:builtins.bool) -> ChannelValueTypePy: ...
    @staticmethod
    def string(value:builtins.str) -> ChannelValueTypePy: ...
    @staticmethod
    def float(value:builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def double(value:builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def int32(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint32(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def int64(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint64(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def enum_value(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def bitfield(value:typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def bytes(value:typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def empty() -> ChannelValueTypePy: ...

@typing.final
class CheckpointMetricsSnapshotPy:
    checkpoint_count: builtins.int
    failed_checkpoint_count: builtins.int
    checkpoint_timer_reached_cnt: builtins.int
    checkpoint_manually_reached_cnt: builtins.int
    cur_elapsed_secs: builtins.float
    cur_messages_sent: builtins.int
    cur_message_rate: builtins.float
    cur_bytes_sent: builtins.int
    cur_byte_rate: builtins.float

@typing.final
class DiskBackupPolicyPy:
    backups_dir: typing.Optional[builtins.str]
    max_backup_file_size: builtins.int
    rolling_file_policy: RollingFilePolicyPy
    retain_backups: builtins.bool
    def __new__(cls, backups_dir:typing.Optional[builtins.str], max_backup_file_size:builtins.int, rolling_file_policy:RollingFilePolicyPy, retain_backups:builtins.bool) -> DiskBackupPolicyPy: ...
    @staticmethod
    def default() -> DiskBackupPolicyPy: ...

@typing.final
class DurationPy:
    secs: builtins.int
    nanos: builtins.int
    def __new__(cls, secs:builtins.int, nanos:builtins.int) -> DurationPy: ...

@typing.final
class FlowBuilderPy:
    def __new__(cls, descriptor:FlowDescriptorPy) -> FlowBuilderPy: ...
    def attach_run_id(self, run_id:builtins.str) -> None:
        r"""
        Attaches a run ID to the flow.
        """
    def set(self, index:ChannelIndexPy, value:ValuePy) -> None:
        r"""
        Sets the value of the channel with the given index.
        """
    def set_with_key(self, key:builtins.str, value:ValuePy) -> None:
        r"""
        Sets the value of the channel with the given key.
        """
    def request(self, now:TimeValuePy) -> IngestWithConfigDataStreamRequestWrapperPy:
        r"""
        Builds an IngestWithConfigDataStreamRequest, consuming the builder.
        """

@typing.final
class FlowConfigPy:
    name: builtins.str
    channels: builtins.list[ChannelConfigPy]
    def __new__(cls, name:builtins.str, channels:typing.Sequence[ChannelConfigPy]) -> FlowConfigPy: ...

@typing.final
class FlowDescriptorBuilderPy:
    def __new__(cls, ingestion_config_id:builtins.str, name:builtins.str) -> FlowDescriptorBuilderPy: ...
    def add(self, key:builtins.str, field_type:ChannelDataTypePy) -> ChannelIndexPy:
        r"""
        Adds a new channel to the flow.
        
        This returns the index of the channel in the flow.
        """
    def build(self) -> FlowDescriptorPy:
        r"""
        Builds the FlowDescriptor from the builder.
        """

@typing.final
class FlowDescriptorPy:
    def get(self, key:builtins.str) -> typing.Optional[ChannelDataTypePy]:
        r"""
        Gets the type of the channel with the given key.
        """
    def mapping(self) -> builtins.dict[builtins.str, ChannelIndexPy]:
        r"""
        Gets the mapping of keys to channel indices.
        """

@typing.final
class FlowPy:
    def __new__(cls, flow_name:builtins.str, timestamp:TimeValuePy, values:typing.Sequence[ChannelValuePy]) -> FlowPy: ...

@typing.final
class IngestWithConfigDataChannelValuePy:
    ty: ChannelValueTypePy
    @staticmethod
    def bool(value:builtins.bool) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def string(value:builtins.str) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def float(value:builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def double(value:builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int32(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint32(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int64(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint64(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def enum_value(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def bitfield(value:typing.Sequence[builtins.int]) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def empty() -> IngestWithConfigDataChannelValuePy: ...

@typing.final
class IngestWithConfigDataStreamRequestPy:
    ingestion_config_id: builtins.str
    flow: builtins.str
    timestamp: typing.Optional[TimeValuePy]
    channel_values: builtins.list[IngestWithConfigDataChannelValuePy]
    run_id: builtins.str
    end_stream_on_validation_error: builtins.bool
    organization_id: builtins.str
    def __new__(cls, ingestion_config_id:builtins.str, flow:builtins.str, timestamp:typing.Optional[TimeValuePy], channel_values:typing.Sequence[IngestWithConfigDataChannelValuePy], run_id:builtins.str, end_stream_on_validation_error:builtins.bool, organization_id:builtins.str) -> IngestWithConfigDataStreamRequestPy: ...

@typing.final
class IngestWithConfigDataStreamRequestWrapperPy:
    ...

@typing.final
class IngestionConfigFormPy:
    asset_name: builtins.str
    flows: builtins.list[FlowConfigPy]
    client_key: builtins.str
    def __new__(cls, asset_name:builtins.str, client_key:builtins.str, flows:typing.Sequence[FlowConfigPy]) -> IngestionConfigFormPy: ...

@typing.final
class MetadataPy:
    key: builtins.str
    value: MetadataValuePy
    def __new__(cls, key:builtins.str, value:MetadataValuePy) -> MetadataPy: ...

@typing.final
class RecoveryStrategyPy:
    @staticmethod
    def retry_only(retry_policy:RetryPolicyPy) -> RecoveryStrategyPy: ...
    @staticmethod
    def retry_with_backups(retry_policy:RetryPolicyPy, disk_backup_policy:DiskBackupPolicyPy) -> RecoveryStrategyPy: ...
    @staticmethod
    def default() -> RecoveryStrategyPy: ...

@typing.final
class RetryPolicyPy:
    max_attempts: builtins.int
    initial_backoff: DurationPy
    max_backoff: DurationPy
    backoff_multiplier: builtins.int
    def __new__(cls, max_attempts:builtins.int, initial_backoff:DurationPy, max_backoff:DurationPy, backoff_multiplier:builtins.int) -> RetryPolicyPy: ...
    @staticmethod
    def default() -> RetryPolicyPy: ...

@typing.final
class RollingFilePolicyPy:
    def __new__(cls, max_file_count:typing.Optional[builtins.int]) -> RollingFilePolicyPy: ...
    @staticmethod
    def default() -> RollingFilePolicyPy: ...

@typing.final
class RunFormPy:
    name: builtins.str
    client_key: builtins.str
    description: typing.Optional[builtins.str]
    tags: typing.Optional[builtins.list[builtins.str]]
    metadata: typing.Optional[builtins.list[MetadataPy]]
    def __new__(cls, name:builtins.str, client_key:builtins.str, description:typing.Optional[builtins.str], tags:typing.Optional[typing.Sequence[builtins.str]], metadata:typing.Optional[typing.Sequence[MetadataPy]]) -> RunFormPy: ...

@typing.final
class RunSelectorPy:
    @staticmethod
    def by_id(run_id:builtins.str) -> RunSelectorPy: ...
    @staticmethod
    def by_form(form:RunFormPy) -> RunSelectorPy: ...

@typing.final
class SiftStreamBuilderPy:
    uri: builtins.str
    apikey: builtins.str
    enable_tls: builtins.bool
    ingestion_config: typing.Optional[IngestionConfigFormPy]
    recovery_strategy: typing.Optional[RecoveryStrategyPy]
    checkpoint_interval: typing.Optional[DurationPy]
    run: typing.Optional[RunFormPy]
    run_id: typing.Optional[builtins.str]
    asset_tags: typing.Optional[builtins.list[builtins.str]]
    metadata: typing.Optional[builtins.list[MetadataPy]]
    def __new__(cls, uri:builtins.str, apikey:builtins.str) -> SiftStreamBuilderPy: ...
    def build(self) -> typing.Any: ...

@typing.final
class SiftStreamMetricsSnapshotPy:
    elapsed_secs: builtins.float
    loaded_flows: builtins.int
    unique_flows_received: builtins.int
    messages_received: builtins.int
    messages_sent: builtins.int
    message_rate: builtins.float
    bytes_sent: builtins.int
    byte_rate: builtins.float
    messages_sent_to_backup: builtins.int
    old_messages_dropped_for_ingestion: builtins.int
    cur_retry_count: builtins.int
    ingestion_channel_depth: builtins.int
    backup_channel_depth: builtins.int
    checkpoint: CheckpointMetricsSnapshotPy
    backups: BackupMetricsSnapshotPy

@typing.final
class SiftStreamPy:
    def send(self, flow:FlowPy) -> typing.Any: ...
    def batch_send(self, flows:typing.Any) -> typing.Any: ...
    def send_requests(self, requests:typing.Sequence[IngestWithConfigDataStreamRequestPy]) -> typing.Any: ...
    def send_requests_nonblocking(self, flows:typing.Any) -> None: ...
    def get_metrics_snapshot(self) -> SiftStreamMetricsSnapshotPy: ...
    def add_new_flows(self, flow_configs:typing.Sequence[FlowConfigPy]) -> typing.Any: ...
    def get_flow_descriptor(self, flow_name:builtins.str) -> FlowDescriptorPy: ...
    def get_flows(self) -> builtins.dict[builtins.str, FlowDescriptorPy]: ...
    def attach_run(self, run_selector:RunSelectorPy) -> typing.Any: ...
    def detach_run(self) -> None: ...
    def run(self) -> typing.Optional[builtins.str]: ...
    def finish(self) -> typing.Any: ...

@typing.final
class TimeValuePy:
    def __new__(cls) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp(secs:builtins.int, nsecs:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_millis(millis:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_micros(micros:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_nanos(nanos:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_rfc3339(val:builtins.str) -> TimeValuePy: ...

@typing.final
class ValuePy:
    @staticmethod
    def Bool(value:builtins.bool) -> ValuePy: ...
    @staticmethod
    def String(value:builtins.str) -> ValuePy: ...
    @staticmethod
    def Float(value:builtins.float) -> ValuePy: ...
    @staticmethod
    def Double(value:builtins.float) -> ValuePy: ...
    @staticmethod
    def Int32(value:builtins.int) -> ValuePy: ...
    @staticmethod
    def Int64(value:builtins.int) -> ValuePy: ...
    @staticmethod
    def Uint32(value:builtins.int) -> ValuePy: ...
    @staticmethod
    def Uint64(value:builtins.int) -> ValuePy: ...
    @staticmethod
    def Enum(value:builtins.int) -> ValuePy: ...
    @staticmethod
    def BitField(value:typing.Sequence[builtins.int]) -> ValuePy: ...
    def is_bool(self) -> builtins.bool: ...
    def is_string(self) -> builtins.bool: ...
    def is_float(self) -> builtins.bool: ...
    def is_double(self) -> builtins.bool: ...
    def is_int32(self) -> builtins.bool: ...
    def is_int64(self) -> builtins.bool: ...
    def is_uint32(self) -> builtins.bool: ...
    def is_uint64(self) -> builtins.bool: ...
    def is_enum(self) -> builtins.bool: ...
    def is_bitfield(self) -> builtins.bool: ...
    def as_bool(self) -> builtins.bool: ...
    def as_string(self) -> builtins.str: ...
    def as_float(self) -> builtins.float: ...
    def as_double(self) -> builtins.float: ...
    def as_int32(self) -> builtins.int: ...
    def as_int64(self) -> builtins.int: ...
    def as_uint32(self) -> builtins.int: ...
    def as_uint64(self) -> builtins.int: ...
    def as_enum(self) -> builtins.int: ...
    def as_bitfield(self) -> builtins.list[builtins.int]: ...

@typing.final
class ChannelDataTypePy(Enum):
    Unspecified = ...
    Double = ...
    String = ...
    Enum = ...
    BitField = ...
    Bool = ...
    Float = ...
    Int32 = ...
    Uint32 = ...
    Int64 = ...
    Uint64 = ...
    Bytes = ...

@typing.final
class MetadataValuePy(Enum):
    String = ...
    Number = ...
    Boolean = ...

    def __new__(cls, obj:typing.Any) -> MetadataValuePy: ...

    def __str__(self) -> builtins.str: ...

    def is_string(self) -> builtins.bool: ...

    def is_number(self) -> builtins.bool: ...

    def is_boolean(self) -> builtins.bool: ...
