# This file is automatically generated by pyo3_stub_gen

__all__ = [
    "ChannelBitFieldElementPy",
    "ChannelConfigPy",
    "ChannelDataTypePy",
    "ChannelEnumTypePy",
    "ChannelValuePy",
    "ChannelValueTypePy",
    "DiskBackupPolicyPy",
    "DurationPy",
    "FlowConfigPy",
    "FlowPy",
    "IngestWithConfigDataChannelValuePy",
    "IngestWithConfigDataStreamRequestPy",
    "IngestionConfigFormPy",
    "MetadataPy",
    "RecoveryStrategyPy",
    "RetryPolicyPy",
    "RollingFilePolicyPy",
    "RunFormPy",
    "SiftStreamBuilderPy",
    "SiftStreamPy",
    "TimeValuePy",
]

import builtins
import typing
from enum import Enum

@typing.final
class ChannelBitFieldElementPy:
    name: builtins.str
    index: builtins.int
    bit_count: builtins.int
    def __new__(cls, name:builtins.str, index:builtins.int, bit_count:builtins.int) -> ChannelBitFieldElementPy: ...

@typing.final
class ChannelConfigPy:
    name: builtins.str
    unit: builtins.str
    description: builtins.str
    data_type: ChannelDataTypePy
    enum_types: builtins.list[ChannelEnumTypePy]
    bit_field_elements: builtins.list[ChannelBitFieldElementPy]
    def __new__(cls, name:builtins.str, unit:builtins.str, description:builtins.str, data_type:ChannelDataTypePy, enum_types:typing.Sequence[ChannelEnumTypePy], bit_field_elements:typing.Sequence[ChannelBitFieldElementPy]) -> ChannelConfigPy: ...

@typing.final
class ChannelEnumTypePy:
    name: builtins.str
    key: builtins.int
    def __new__(cls, name:builtins.str, key:builtins.int) -> ChannelEnumTypePy: ...

@typing.final
class ChannelValuePy:
    @staticmethod
    def bool(name:builtins.str, value:builtins.bool) -> ChannelValuePy: ...
    @staticmethod
    def string(name:builtins.str, value:builtins.str) -> ChannelValuePy: ...
    @staticmethod
    def float(name:builtins.str, value:builtins.float) -> ChannelValuePy: ...
    @staticmethod
    def double(name:builtins.str, value:builtins.float) -> ChannelValuePy: ...
    @staticmethod
    def int32(name:builtins.str, value:builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def uint32(name:builtins.str, value:builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def int64(name:builtins.str, value:builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def uint64(name:builtins.str, value:builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def enum_value(name:builtins.str, value:ChannelEnumTypePy) -> ChannelValuePy: ...
    @staticmethod
    def bitfield(name:builtins.str, value:typing.Sequence[builtins.int]) -> ChannelValuePy: ...

@typing.final
class ChannelValueTypePy:
    @staticmethod
    def bool(value:builtins.bool) -> ChannelValueTypePy: ...
    @staticmethod
    def string(value:builtins.str) -> ChannelValueTypePy: ...
    @staticmethod
    def float(value:builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def double(value:builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def int32(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint32(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def int64(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint64(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def enum_value(value:builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def bitfield(value:typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def bytes(value:typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def empty() -> ChannelValueTypePy: ...

@typing.final
class DiskBackupPolicyPy:
    backups_dir: typing.Optional[builtins.str]
    max_backup_file_size: builtins.int
    rolling_file_policy: RollingFilePolicyPy
    retain_backups: builtins.bool
    def __new__(cls, backups_dir:typing.Optional[builtins.str], max_backup_file_size:builtins.int, rolling_file_policy:RollingFilePolicyPy, retain_backups:builtins.bool) -> DiskBackupPolicyPy: ...
    @staticmethod
    def default() -> DiskBackupPolicyPy: ...

@typing.final
class DurationPy:
    secs: builtins.int
    nanos: builtins.int
    def __new__(cls, secs:builtins.int, nanos:builtins.int) -> DurationPy: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class FlowConfigPy:
    name: builtins.str
    channels: builtins.list[ChannelConfigPy]
    def __new__(cls, name:builtins.str, channels:typing.Sequence[ChannelConfigPy]) -> FlowConfigPy: ...

@typing.final
class FlowPy:
    def __new__(cls, flow_name:builtins.str, timestamp:TimeValuePy, values:typing.Sequence[ChannelValuePy]) -> FlowPy: ...

@typing.final
class IngestWithConfigDataChannelValuePy:
    r#type: ChannelValueTypePy
    @staticmethod
    def bool(value:builtins.bool) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def string(value:builtins.str) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def float(value:builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def double(value:builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int32(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint32(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int64(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint64(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def enum_value(value:builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def bitfield(value:typing.Sequence[builtins.int]) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def empty() -> IngestWithConfigDataChannelValuePy: ...

@typing.final
class IngestWithConfigDataStreamRequestPy:
    ingestion_config_id: builtins.str
    flow: builtins.str
    timestamp: typing.Optional[TimeValuePy]
    channel_values: builtins.list[IngestWithConfigDataChannelValuePy]
    run_id: builtins.str
    end_stream_on_validation_error: builtins.bool
    organization_id: builtins.str
    def __new__(cls, ingestion_config_id:builtins.str, flow:builtins.str, timestamp:typing.Optional[TimeValuePy], channel_values:typing.Sequence[IngestWithConfigDataChannelValuePy], run_id:builtins.str, end_stream_on_validation_error:builtins.bool, organization_id:builtins.str) -> IngestWithConfigDataStreamRequestPy: ...

@typing.final
class IngestionConfigFormPy:
    asset_name: builtins.str
    flows: builtins.list[FlowConfigPy]
    client_key: builtins.str
    def __new__(cls, asset_name:builtins.str, client_key:builtins.str, flows:typing.Sequence[FlowConfigPy]) -> IngestionConfigFormPy: ...

@typing.final
class MetadataPy:
    key: builtins.str
    value: MetadataValue

@typing.final
class RecoveryStrategyPy:
    @staticmethod
    def retry_only(retry_policy:RetryPolicyPy) -> RecoveryStrategyPy: ...
    @staticmethod
    def retry_with_backups(retry_policy:RetryPolicyPy, disk_backup_policy:DiskBackupPolicyPy) -> RecoveryStrategyPy: ...
    @staticmethod
    def default() -> RecoveryStrategyPy: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class RetryPolicyPy:
    max_attempts: builtins.int
    initial_backoff: DurationPy
    max_backoff: DurationPy
    backoff_multiplier: builtins.int
    def __new__(cls, max_attempts:builtins.int, initial_backoff:DurationPy, max_backoff:DurationPy, backoff_multiplier:builtins.int) -> RetryPolicyPy: ...
    @staticmethod
    def default() -> RetryPolicyPy: ...

@typing.final
class RollingFilePolicyPy:
    def __new__(cls, max_file_count:typing.Optional[builtins.int]) -> RollingFilePolicyPy: ...
    @staticmethod
    def default() -> RollingFilePolicyPy: ...

@typing.final
class RunFormPy:
    name: builtins.str
    client_key: builtins.str
    description: typing.Optional[builtins.str]
    tags: typing.Optional[builtins.list[builtins.str]]
    metadata: typing.Optional[builtins.list[MetadataPy]]
    def __new__(cls, name:builtins.str, client_key:builtins.str, description:typing.Optional[builtins.str], tags:typing.Optional[typing.Sequence[builtins.str]], metadata:typing.Optional[typing.Sequence[MetadataPy]]) -> RunFormPy: ...

@typing.final
class SiftStreamBuilderPy:
    uri: builtins.str
    apikey: builtins.str
    enable_tls: builtins.bool
    ingestion_config: typing.Optional[IngestionConfigFormPy]
    recovery_strategy: typing.Optional[RecoveryStrategyPy]
    checkpoint_interval: DurationPy
    run: typing.Optional[RunFormPy]
    run_id: typing.Optional[builtins.str]
    asset_tags: typing.Optional[builtins.list[builtins.str]]
    metadata: typing.Optional[builtins.list[MetadataPy]]
    def __new__(cls, uri:builtins.str, apikey:builtins.str) -> SiftStreamBuilderPy: ...
    def build(self) -> typing.Any: ...

@typing.final
class SiftStreamPy:
    def send(self, flow:FlowPy) -> typing.Any: ...
    def send_requests(self, requests:typing.Sequence[IngestWithConfigDataStreamRequestPy]) -> typing.Any: ...
    def finish(self) -> typing.Any: ...

@typing.final
class TimeValuePy:
    def __new__(cls) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp(secs:builtins.int, nsecs:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_millis(millis:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_micros(micros:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_nanos(nanos:builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_rfc3339(val:builtins.str) -> TimeValuePy: ...

@typing.final
class ChannelDataTypePy(Enum):
    Unspecified = ...
    Double = ...
    String = ...
    Enum = ...
    BitField = ...
    Bool = ...
    Float = ...
    Int32 = ...
    Uint32 = ...
    Int64 = ...
    Uint64 = ...
    Bytes = ...

class MetadataValue(Enum):
    String = ...
    Number = ...
    Boolean = ...
