# This file is automatically generated by pyo3_stub_gen

__all__ = [
    "ChannelBitFieldElementPy",
    "ChannelConfigPy",
    "ChannelDataTypePy",
    "ChannelEnumTypePy",
    "ChannelValuePy",
    "ChannelValueTypePy",
    "DurationPy",
    "FlowConfigPy",
    "FlowPy",
    "IngestWithConfigDataChannelValuePy",
    "IngestWithConfigDataStreamRequestPy",
    "IngestionConfigFormPy",
    "RecoveryStrategyPy",
    "RetryPolicyPy",
    "RunFormPy",
    "SiftStreamBuilderPy",
    "SiftStreamPy",
    "TimeValuePy",
]

import builtins
import typing
from enum import Enum

@typing.final
class ChannelBitFieldElementPy:
    name: builtins.str
    index: builtins.int
    bit_count: builtins.int
    def __new__(
        cls, name: builtins.str, index: builtins.int, bit_count: builtins.int
    ) -> ChannelBitFieldElementPy: ...

@typing.final
class ChannelConfigPy:
    name: builtins.str
    unit: builtins.str
    description: builtins.str
    data_type: ChannelDataTypePy
    enum_types: builtins.list[ChannelEnumTypePy]
    bit_field_elements: builtins.list[ChannelBitFieldElementPy]
    def __new__(
        cls,
        name: builtins.str,
        unit: builtins.str,
        description: builtins.str,
        data_type: ChannelDataTypePy,
        enum_types: typing.Sequence[ChannelEnumTypePy],
        bit_field_elements: typing.Sequence[ChannelBitFieldElementPy],
    ) -> ChannelConfigPy: ...

@typing.final
class ChannelEnumTypePy:
    name: builtins.str
    key: builtins.int
    def __new__(cls, name: builtins.str, key: builtins.int) -> ChannelEnumTypePy: ...

@typing.final
class ChannelValuePy:
    @staticmethod
    def bool(name: builtins.str, value: builtins.bool) -> ChannelValuePy: ...
    @staticmethod
    def string(name: builtins.str, value: builtins.str) -> ChannelValuePy: ...
    @staticmethod
    def float(name: builtins.str, value: builtins.float) -> ChannelValuePy: ...
    @staticmethod
    def double(name: builtins.str, value: builtins.float) -> ChannelValuePy: ...
    @staticmethod
    def int32(name: builtins.str, value: builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def uint32(name: builtins.str, value: builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def int64(name: builtins.str, value: builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def uint64(name: builtins.str, value: builtins.int) -> ChannelValuePy: ...
    @staticmethod
    def enum_value(name: builtins.str, value: ChannelEnumTypePy) -> ChannelValuePy: ...
    @staticmethod
    def bitfield(
        name: builtins.str, value: typing.Sequence[builtins.int]
    ) -> ChannelValuePy: ...

@typing.final
class ChannelValueTypePy:
    @staticmethod
    def bool(value: builtins.bool) -> ChannelValueTypePy: ...
    @staticmethod
    def string(value: builtins.str) -> ChannelValueTypePy: ...
    @staticmethod
    def float(value: builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def double(value: builtins.float) -> ChannelValueTypePy: ...
    @staticmethod
    def int32(value: builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint32(value: builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def int64(value: builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def uint64(value: builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def enum_value(value: builtins.int) -> ChannelValueTypePy: ...
    @staticmethod
    def bitfield(value: typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def bytes(value: typing.Sequence[builtins.int]) -> ChannelValueTypePy: ...
    @staticmethod
    def empty() -> ChannelValueTypePy: ...

@typing.final
class DurationPy:
    secs: builtins.int
    nanos: builtins.int
    def __new__(cls, secs: builtins.int, nanos: builtins.int) -> DurationPy: ...

@typing.final
class FlowConfigPy:
    name: builtins.str
    channels: builtins.list[ChannelConfigPy]
    def __new__(
        cls, name: builtins.str, channels: typing.Sequence[ChannelConfigPy]
    ) -> FlowConfigPy: ...

@typing.final
class FlowPy:
    def __new__(
        cls,
        flow_name: builtins.str,
        timestamp: TimeValuePy,
        values: typing.Sequence[ChannelValuePy],
    ) -> FlowPy: ...

@typing.final
class IngestWithConfigDataChannelValuePy:
    @staticmethod
    def bool(value: builtins.bool) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def string(value: builtins.str) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def float(value: builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def double(value: builtins.float) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int32(value: builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint32(value: builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def int64(value: builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def uint64(value: builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def enum_value(value: builtins.int) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def bitfield(
        value: typing.Sequence[builtins.int],
    ) -> IngestWithConfigDataChannelValuePy: ...
    @staticmethod
    def empty() -> IngestWithConfigDataChannelValuePy: ...

@typing.final
class IngestWithConfigDataStreamRequestPy:
    ingestion_config_id: builtins.str
    flow: builtins.str
    timestamp: typing.Optional[TimeValuePy]
    channel_values: builtins.list[IngestWithConfigDataChannelValuePy]
    run_id: builtins.str
    end_stream_on_validation_error: builtins.bool
    organization_id: builtins.str
    def __new__(
        cls,
        ingestion_config_id: builtins.str,
        flow: builtins.str,
        timestamp: typing.Optional[TimeValuePy],
        channel_values: typing.Sequence[IngestWithConfigDataChannelValuePy],
        run_id: builtins.str,
        end_stream_on_validation_error: builtins.bool,
        organization_id: builtins.str,
    ) -> IngestWithConfigDataStreamRequestPy: ...

@typing.final
class IngestionConfigFormPy:
    asset_name: builtins.str
    flows: builtins.list[FlowConfigPy]
    client_key: builtins.str
    def __new__(
        cls,
        asset_name: builtins.str,
        client_key: builtins.str,
        flows: typing.Sequence[FlowConfigPy],
    ) -> IngestionConfigFormPy: ...

@typing.final
class RecoveryStrategyPy:
    strategy_type: builtins.str
    retry_policy: typing.Optional[RetryPolicyPy]
    max_buffer_size: typing.Optional[builtins.int]
    backups_dir: typing.Optional[builtins.str]
    max_backups_file_size: typing.Optional[builtins.int]
    def __new__(
        cls,
        strategy_type: builtins.str,
        retry_policy: typing.Optional[RetryPolicyPy],
        max_buffer_size: typing.Optional[builtins.int],
        backups_dir: typing.Optional[builtins.str],
        max_backups_file_size: typing.Optional[builtins.int],
    ) -> RecoveryStrategyPy: ...
    @staticmethod
    def retry_only(retry_policy: RetryPolicyPy) -> RecoveryStrategyPy: ...
    @staticmethod
    def retry_with_in_memory_backups(
        retry_policy: RetryPolicyPy, max_buffer_size: typing.Optional[builtins.int]
    ) -> RecoveryStrategyPy: ...
    @staticmethod
    def retry_with_disk_backups(
        retry_policy: RetryPolicyPy,
        backups_dir: typing.Optional[builtins.str],
        max_backups_file_size: typing.Optional[builtins.int],
    ) -> RecoveryStrategyPy: ...
    @staticmethod
    def default() -> RecoveryStrategyPy: ...
    @staticmethod
    def default_retry_policy_in_memory_backups() -> RecoveryStrategyPy: ...
    @staticmethod
    def default_retry_policy_disk_backups() -> RecoveryStrategyPy: ...

@typing.final
class RetryPolicyPy:
    max_attempts: builtins.int
    initial_backoff: DurationPy
    max_backoff: DurationPy
    backoff_multiplier: builtins.int
    def __new__(
        cls,
        max_attempts: builtins.int,
        initial_backoff: DurationPy,
        max_backoff: DurationPy,
        backoff_multiplier: builtins.int,
    ) -> RetryPolicyPy: ...
    @staticmethod
    def default() -> RetryPolicyPy: ...

@typing.final
class RunFormPy:
    name: builtins.str
    client_key: builtins.str
    description: typing.Optional[builtins.str]
    tags: typing.Optional[builtins.list[builtins.str]]
    def __new__(
        cls,
        name: builtins.str,
        client_key: builtins.str,
        description: typing.Optional[builtins.str],
        tags: typing.Optional[typing.Sequence[builtins.str]],
    ) -> RunFormPy: ...

@typing.final
class SiftStreamBuilderPy:
    uri: builtins.str
    apikey: builtins.str
    enable_tls: builtins.bool
    ingestion_config: typing.Optional[IngestionConfigFormPy]
    recovery_strategy: typing.Optional[RecoveryStrategyPy]
    checkpoint_interval: DurationPy
    run: typing.Optional[RunFormPy]
    run_id: typing.Optional[builtins.str]
    def __new__(
        cls, uri: builtins.str, apikey: builtins.str
    ) -> SiftStreamBuilderPy: ...
    def build(self) -> typing.Any: ...

@typing.final
class SiftStreamPy:
    def send(self, flow: FlowPy) -> typing.Any: ...
    def send_requests(
        self, requests: typing.Sequence[IngestWithConfigDataStreamRequestPy]
    ) -> typing.Any: ...
    def finish(self) -> typing.Any: ...

@typing.final
class TimeValuePy:
    def __new__(cls) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp(secs: builtins.int, nsecs: builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_millis(millis: builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_micros(micros: builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_timestamp_nanos(nanos: builtins.int) -> TimeValuePy: ...
    @staticmethod
    def from_rfc3339(val: builtins.str) -> TimeValuePy: ...

@typing.final
class ChannelDataTypePy(Enum):
    Unspecified = ...
    Double = ...
    String = ...
    Enum = ...
    BitField = ...
    Bool = ...
    Float = ...
    Int32 = ...
    Uint32 = ...
    Int64 = ...
    Uint64 = ...
    Bytes = ...
